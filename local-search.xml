<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hadoop</title>
    <link href="/2021/10/25/hadoop/"/>
    <url>/2021/10/25/hadoop/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流</title>
    <link href="/2021/10/11/IO%E6%B5%81/"/>
    <url>/2021/10/11/IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="学习IO"><a href="#学习IO" class="headerlink" title="学习IO"></a>学习IO</h3><hr><p>IO是指Input/Output，即输入和输出。以内存为中心：</p><ul><li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><p>为什么要把数据读到内存才能处理这些数据？因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。</p><p>从Java代码来看，输入实际上就是从外部，例如，硬盘上的某个文件，把内容读到内存，并且以Java提供的某种数据类型表示，例如，<code>byte[]</code>，<code>String</code>，这样，后续代码才能处理这些数据。</p><p>因为内存有“易失性”的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output实际上就是把Java表示的数据格式，例如，<code>byte[]</code>，<code>String</code>等输出到某个地方。</p><p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p><h4 id="InputStream-OutputStream"><a href="#InputStream-OutputStream" class="headerlink" title="InputStream / OutputStream"></a>InputStream / OutputStream</h4><p>IO流以<code>byte</code>（字节）为最小单位，因此也称为<em>字节流</em>。例如，我们要从磁盘读入一个文件，包含6个字节，就相当于读入了6个字节的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ascii">╔════════════╗<br>║   Memory   ║<br>╚════════════╝<br>       ▲<br>       │0x48<br>       │0x65<br>       │0x6c<br>       │0x6c<br>       │0x6f<br>       │0x21<br> ╔═══════════╗<br> ║ Hard Disk ║<br> ╚═══════════╝<br></code></pre></td></tr></table></figure><p>这6个字节是按顺序读入的，所以是输入字节流。</p><p>反过来，我们把6个字节从内存写入磁盘文件，就是输出字节流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ascii">╔════════════╗<br>║   Memory   ║<br>╚════════════╝<br>       │0x21<br>       │0x6f<br>       │0x6c<br>       │0x6c<br>       │0x65<br>       │0x48<br>       ▼<br> ╔═══════════╗<br> ║ Hard Disk ║<br> ╚═══════════╝<br></code></pre></td></tr></table></figure><p>在Java中，<code>InputStream</code>代表输入字节流，<code>OuputStream</code>代表输出字节流，这是最基本的两种IO流。</p><h4 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader / Writer"></a>Reader / Writer</h4><p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照<code>char</code>来读写显然更方便，这种流称为==<em>字符流</em>。==</p><p>Java提供了<code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。</p><p>例如，我们把<code>char[]</code>数组<code>Hi你好</code>这4个字符用<code>Writer</code>字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符<code>H</code>和<code>i</code>各占一个字节，中文字符<code>你好</code>各占3个字节：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x48</span><br><span class="hljs-number">0x69</span><br><span class="hljs-number">0xe4bda0</span><br><span class="hljs-number">0xe5a5bd</span><br></code></pre></td></tr></table></figure><p>反过来，我们用<code>Reader</code>读取以UTF-8编码的这8个字节，会从<code>Reader</code>中得到<code>Hi你好</code>这4个字符。</p><p>因此，<code>Reader</code>和<code>Writer</code>本质上是一个能自动编解码的<code>InputStream</code>和<code>OutputStream</code>。</p><p>使用<code>Reader</code>，数据源虽然是字节，但我们读入的数据都是<code>char</code>类型的字符，原因是<code>Reader</code>内部把读入的<code>byte</code>做了解码，转换成了<code>char</code>。使用<code>InputStream</code>，我们读入的数据和原始二进制数据一模一样，是<code>byte[]</code>数组，但是我们可以自己把二进制<code>byte[]</code>数组按照某种编码转换为字符串。究竟使用<code>Reader</code>还是<code>InputStream</code>，要取决于具体的使用场景。如果数据源不是文本，就只能使用<code>InputStream</code>，如果数据源是文本，使用Reader更方便一些。<code>Writer</code>和<code>OutputStream</code>是类似的。</p><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p><p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p><p>Java标准库的包<code>java.io</code>提供了同步IO，而<code>java.nio</code>则是异步IO。上面我们讨论的<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>和<code>Writer</code>都是同步IO的抽象类，对应的具体实现类，以文件为例，有<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>和<code>FileWriter</code>。</p><p>本节我们只讨论Java的同步IO，即输入/输出流的IO模型。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>IO流是一种流式的数据输入/输出模型：</p><ul><li>二进制数据以<code>byte</code>为最小单位在<code>InputStream</code>/<code>OutputStream</code>中单向流动；</li><li>字符数据以<code>char</code>为最小单位在<code>Reader</code>/<code>Writer</code>中单向流动。</li></ul><p>Java标准库的<code>java.io</code>包提供了同步IO功能：</p><ul><li>字节流接口：<code>InputStream</code>/<code>OutputStream</code>；</li><li>字符流接口：<code>Reader</code>/<code>Writer</code></li></ul><hr><h4 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h4><p>计算机系统中，文件是非常重要的存储方式。Java的标准库<code>java.io</code>提供了<code>File</code>对象来操作文件和目录。</p><p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Windows\\notepad.exe&quot;</span>);<br></code></pre></td></tr></table></figure><p>==注意Windows平台使用<code>\</code>作为路径分隔符，在Java字符串中需要用<code>\\</code>表示一个<code>\</code>。Linux平台使用<code>/</code>作为路径分隔符==：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/usr/bin/javac&quot;</span>);<br></code></pre></td></tr></table></figure><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><p>可以用<code>.</code>表示当前目录，<code>..</code>表示上级目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设当前目录是C:\Docs</span><br>File f1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;sub\\javac&quot;</span>); <span class="hljs-comment">// 绝对路径是C:\Docs\sub\javac</span><br>File f3 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;.\\sub\\javac&quot;</span>); <span class="hljs-comment">// 绝对路径是C:\Docs\sub\javac</span><br>File f3 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;..\\sub\\javac&quot;</span>); <span class="hljs-comment">// 绝对路径是C:\sub\javac</span><br></code></pre></td></tr></table></figure><h4 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h4><p><code>File</code>对象既可以表示文件，也可以表示目录</p><p>==构造一个<code>File</code>对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个<code>File</code>对象，并不会导致任何磁盘操作。==</p><p>调用<code>File</code>对象的某些方法的时候，才真正进行磁盘操作。</p><ul><li>调用<code>isFile()</code>，判断该<code>File</code>对象是否是一个已存在的文件，</li><li>调用<code>isDirectory()</code>，判断该<code>File</code>对象是否是一个已存在的目录：</li></ul><p>用<code>File</code>对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p><ul><li><code>boolean canRead()</code>：是否可读；</li><li><code>boolean canWrite()</code>：是否可写；</li><li><code>boolean canExecute()</code>：是否可执行；</li><li><code>long length()</code>：文件字节大小。</li></ul><p>对目录而言，是否可执行表示<strong>能否列出</strong>它包含的文件和子目录。</p><h4 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h4><p>当File对象表示一个文件时，可以通过<code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/path/to/file&quot;</span>);<br><span class="hljs-keyword">if</span> (file.createNewFile()) &#123;<br>    <span class="hljs-comment">// 文件创建成功:</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>    <span class="hljs-keyword">if</span> (file.delete()) &#123;<br>        <span class="hljs-comment">// 删除文件成功:</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序需要读写一些临时文件，File对象提供了<code>createTempFile()</code>来创建一个临时文件，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File f = File.createTempFile(<span class="hljs-string">&quot;tmp-&quot;</span>, <span class="hljs-string">&quot;.txt&quot;</span>); <span class="hljs-comment">// 提供临时文件的前缀和后缀</span><br>        f.deleteOnExit(); <span class="hljs-comment">// JVM退出时自动删除</span><br>        System.out.println(f.isFile());<br>        System.out.println(f.getAbsolutePath());<br>    &#125;<br></code></pre></td></tr></table></figure><hr><p>上面是表示文件的情况</p><p>下面是表现为目录的情况</p><hr><p>当File对象表示一个==目录==时，可以使用<code>list()</code>和<code>listFiles()</code>列出目录下的文件和子目录名。<code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Windows&quot;</span>);<br>        File[] fs1 = f.listFiles(); <span class="hljs-comment">// 列出所有文件和子目录</span><br>        printFiles(fs1);<br>        File[] fs2 = f.listFiles(<span class="hljs-keyword">new</span> FilenameFilter() &#123; <span class="hljs-comment">// 仅列出.exe文件</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span><span class="hljs-params">(File dir, String name)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> name.endsWith(<span class="hljs-string">&quot;.exe&quot;</span>); <span class="hljs-comment">// 返回true表示接受该文件</span><br>            &#125;<br>        &#125;);<br>        printFiles(fs2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printFiles</span><span class="hljs-params">(File[] files)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==========&quot;</span>);<br>        <span class="hljs-keyword">if</span> (files != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (File f : files) &#123;<br>                System.out.println(f);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;==========&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p><ul><li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li><li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li><li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li></ul><h4 id="Path-异步IO里面的，也可以用在同步IO中"><a href="#Path-异步IO里面的，也可以用在同步IO中" class="headerlink" title="Path(异步IO里面的，也可以用在同步IO中)"></a>Path(异步IO里面的，也可以用在同步IO中)</h4><p>Java标准库还提供了一个<code>Path</code>对象，它位于<code>java.nio.file</code>包。<code>Path</code>对象和<code>File</code>对象类似，但操作更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Path p1 = Paths.get(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;project&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>); <span class="hljs-comment">// 构造一个Path对象</span><br>        System.out.println(p1);<br>        Path p2 = p1.toAbsolutePath(); <span class="hljs-comment">// 转换为绝对路径</span><br>        System.out.println(p2);<br>        Path p3 = p2.normalize(); <span class="hljs-comment">// 转换为规范路径</span><br>        System.out.println(p3);<br>        File f = p3.toFile(); <span class="hljs-comment">// 转换为File对象</span><br>        System.out.println(f);<br>        <span class="hljs-keyword">for</span> (Path p : Paths.get(<span class="hljs-string">&quot;..&quot;</span>).toAbsolutePath()) &#123; <span class="hljs-comment">// 可以直接遍历Path</span><br>            System.out.println(<span class="hljs-string">&quot;  &quot;</span> + p);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法：</p><ul><li>Path p1 = Paths.get(“.”, “project”, “study”); // 构造一个Path对象</li><li>Path p2 = p1.toAbsolutePath(); // 转换为绝对路径</li><li>Path p3 = p2.normalize(); // 转换为规范路径</li><li>File f = p3.toFile(); // 转换为File对象</li></ul><p>如果需要对目录进行复杂的拼接、遍历等操作，使用<code>Path</code>对象更方便。</p><hr><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>Java标准库的<code>java.io.File</code>对象表示一个文件或者目录：</p><ul><li>创建<code>File</code>对象本身不涉及IO操作；</li><li>可以获取路径／绝对路径／规范路径：<code>getPath()</code>/<code>getAbsolutePath()</code>/<code>getCanonicalPath()</code>；</li><li>可以获取目录的文件和子目录：<code>list()</code>/<code>listFiles()</code>；</li><li>可以创建或删除文件和目录。</li></ul><hr><p>InputStream</p><p><code>InputStream</code>就是Java标准库提供的最基本的输入流。它位于<code>java.io</code>这个包里。<code>java.io</code>包提供了所有同步IO的功能。</p><p><code>InputStream</code>并不是一个接口，而是一个==抽象类==，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是<code>int read()</code>，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br></code></pre></td></tr></table></figure><p>这个方法会读取输入流的下一个字节，并返回字节表示的<code>int</code>值（0~255）。如果已读到末尾，返回<code>-1</code>表示不能继续读取了。</p><p><code>FileInputStream</code>是<code>InputStream</code>的一个子类。顾名思义，<code>FileInputStream</code>就是从文件流中读取数据。</p><p><code>InputStream</code>和<code>OutputStream</code>都是通过<code>close()</code>方法来关闭流。关闭流就会释放对应的底层资源。</p><p>因此，我们需要用<code>try ... finally</code>来保证<code>InputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    InputStream input = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        input = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;src/readme.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">while</span> ((n = input.read()) != -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 利用while同时读取并判断</span><br>            System.out.println(n);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (input != <span class="hljs-keyword">null</span>) &#123; input.close(); &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用Java 7引入的新的<code>try(resource)</code>的语法，只需要编写<code>try</code>语句，让编译器自动为我们关闭资源。推荐的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span> (InputStream input = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;src/readme.txt&quot;</span>)) &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">while</span> ((n = input.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(n);<br>        &#125;<br>    &#125; <span class="hljs-comment">// 编译器在此自动为我们写入finally并调用close()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口</p><hr><h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多</p><p><code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p><ul><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>利用上述方法一次读取多个字节时，</p><ul><li><p>需要先定义一个<code>byte[]</code>数组作为缓冲区，</p></li><li><p><code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。</p></li><li><p><code>ead()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。</p></li><li><p>如果返回<code>-1</code>，表示没有更多的数据了。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span> (InputStream input = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;src/readme.txt&quot;</span>)) &#123;<br>        <span class="hljs-comment">// 定义1000个字节大小的缓冲区:</span><br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1000</span>];<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">while</span> ((n = input.read(buffer)) != -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 读取到缓冲区</span><br>            System.out.println(<span class="hljs-string">&quot;read &quot;</span> + n + <span class="hljs-string">&quot; bytes.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n;<br>n = input.read(); <span class="hljs-comment">// 必须等待read()方法返回才能执行下一行代码</span><br><span class="hljs-keyword">int</span> m = n;<br></code></pre></td></tr></table></figure><p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p><h4 id="InputStream实现类"><a href="#InputStream实现类" class="headerlink" title="InputStream实现类"></a>InputStream实现类</h4><p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。此外，<code>ByteArrayInputStream</code>可以在内存中模拟一个<code>InputStream</code>：</p><p><code>ByteArrayInputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>InputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>InputStream</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] data = &#123; <span class="hljs-number">72</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>, <span class="hljs-number">33</span> &#125;;<br>        <span class="hljs-keyword">try</span> (InputStream input = <span class="hljs-keyword">new</span> ByteArrayInputStream(data)) &#123;<br>            String s = readAsString(input);<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">readAsString</span><span class="hljs-params">(InputStream input)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">int</span> n;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">while</span> ((n = input.read()) != -<span class="hljs-number">1</span>) &#123;<br>            sb.append((<span class="hljs-keyword">char</span>) n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是面向抽象编程原则的应用：接受<code>InputStream</code>抽象类型，而不是具体的<code>FileInputStream</code>类型，从而使得代码可以处理<code>InputStream</code>的任意实现类。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>Java标准库的<code>java.io.InputStream</code>定义了所有输入流的超类：</p><ul><li><code>FileInputStream</code>实现了文件流输入；</li><li><code>ByteArrayInputStream</code>在内存中模拟一个字节流输入。</li></ul><p>总是使用<code>try(resource)</code>来保证<code>InputStream</code>正确关闭。</p><hr><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p>和<code>InputStream</code>相反，<code>OutputStream</code>是Java标准库提供的最基本的输出流。</p><p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br></code></pre></td></tr></table></figure><p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是<code>int</code>参数，但只会写入一个字节，即只写入<code>int</code>最低8位表示字节的部分（相当于<code>b &amp; 0xff</code>）</p><p><code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：==<code>OutputStream</code>还提供了一个<code>flush()</code>方法==，它的目的是将缓冲区的内容真正输出到目的地。</p><p><strong>为什么要有<code>flush()</code>？</strong></p><p>因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以<code>OutputStream</code>有个<code>flush()</code>方法，能强制把缓冲区内容输出。</p><p>通常情况下，我们不需要调用这个<code>flush()</code>方法，<strong>因为缓冲区写满了<code>OutputStream</code>会自动调用它</strong>，并且，在调用<code>close()</code>方法关闭<code>OutputStream</code>之前，也会自动调用<code>flush()</code>方法。</p><p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过<code>OutputStream</code>的<code>write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？</p><p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p><p>解决办法就是每输入一句话后，立刻调用<code>flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p><p><code>InputStream</code>也有缓冲区。例如，从<code>FileInputStream</code>读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用<code>int read()</code>读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用<code>read()</code>，则会触发操作系统的下一次读取并再次填满缓冲区。</p><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p>每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用<code>OutputStream</code>提供的重载方法<code>void write(byte[])</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    OutputStream output = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;out/readme.txt&quot;</span>);<br>    output.write(<span class="hljs-string">&quot;Hello&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>)); <span class="hljs-comment">// Hello</span><br>    output.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="阻塞-1"><a href="#阻塞-1" class="headerlink" title="阻塞"></a>阻塞</h4><p>和<code>InputStream</code>一样，<code>OutputStream</code>的<code>write()</code>方法也是阻塞的。</p><h4 id="OutputStream实现类"><a href="#OutputStream实现类" class="headerlink" title="OutputStream实现类"></a>OutputStream实现类</h4><p>用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>：</p><p>和ByteArrayInputStream差不多。</p><hr><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>Java标准库的<code>java.io.OutputStream</code>定义了所有输出流的超类：</p><ul><li><code>FileOutputStream</code>实现了文件流输出；</li><li><code>ByteArrayOutputStream</code>在内存中模拟一个字节流输出。</li></ul><p>某些情况下需要手动调用<code>OutputStream</code>的<code>flush()</code>方法来强制输出缓冲区。</p><p>总是使用<code>try(resource)</code>来保证<code>OutputStream</code>正确关闭。</p><hr><h4 id="Filter模式（装饰器模式）"><a href="#Filter模式（装饰器模式）" class="headerlink" title="Filter模式（装饰器模式）"></a>Filter模式（装饰器模式）</h4><p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将<code>InputStream</code>分为两大类：</p><p>一类是直接提供数据的基础<code>InputStream</code>，例如：</p><ul><li>FileInputStream</li><li>ByteArrayInputStream</li><li>ServletInputStream</li><li>…</li></ul><p>一类是提供额外附加功能的<code>InputStream</code>，例如：</p><ul><li>BufferedInputStream</li><li>DigestInputStream</li><li>CipherInputStream</li><li>…</li></ul><p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">InputStream file</span> = new FileInputStream(<span class="hljs-string">&quot;test.gz&quot;</span>);<br></code></pre></td></tr></table></figure><p>紧接着，我们希望<code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code>BufferedInputStream</code>包装这个<code>InputStream</code>，得到的包装类型是<code>BufferedInputStream</code>，但它仍然被视为一个<code>InputStream</code>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">InputStream buffered = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BufferedInputStream(<span class="hljs-params">file</span>)</span>;<br></code></pre></td></tr></table></figure><p>最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code>GZIPInputStream</code>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">InputStream gzip = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GZIPInputStream(<span class="hljs-params">buffered</span>)</span>;<br></code></pre></td></tr></table></figure><p>无论我们包装多少次，得到的对象始终是<code>InputStream</code>，我们直接用<code>InputStream</code>来引用它，就可以正常读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌─────────────────────────┐<br>│GZIPInputStream          │<br>│┌───────────────────────┐│<br>││BufferedFileInputStream││<br>││┌─────────────────────┐││<br>│││   FileInputStream   │││<br>││└─────────────────────┘││<br>│└───────────────────────┘│<br>└─────────────────────────┘<br></code></pre></td></tr></table></figure><p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                 ┌─────────────┐<br>                 │ InputStream │<br>                 └─────────────┘<br>                       ▲ ▲<br>┌────────────────────┐ │ │ ┌─────────────────┐<br>│  FileInputStream   │─┤ └─│FilterInputStream│<br>└────────────────────┘ │   └─────────────────┘<br>┌────────────────────┐ │     ▲ ┌───────────────────┐<br>│ByteArrayInputStream│─┤     ├─│BufferedInputStream│<br>└────────────────────┘ │     │ └───────────────────┘<br>┌────────────────────┐ │     │ ┌───────────────────┐<br>│ ServletInputStream │─┘     ├─│  DataInputStream  │<br>└────────────────────┘       │ └───────────────────┘<br>                             │ ┌───────────────────┐<br>                             └─│CheckedInputStream │<br>                               └───────────────────┘<br></code></pre></td></tr></table></figure><p>类似的，<code>OutputStream</code>也是以这种模式来提供各种功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                  ┌─────────────┐<br>                  │OutputStream │<br>                  └─────────────┘<br>                        ▲ ▲<br>┌─────────────────────┐ │ │ ┌──────────────────┐<br>│  FileOutputStream   │─┤ └─│FilterOutputStream│<br>└─────────────────────┘ │   └──────────────────┘<br>┌─────────────────────┐ │     ▲ ┌────────────────────┐<br>│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│<br>└─────────────────────┘ │     │ └────────────────────┘<br>┌─────────────────────┐ │     │ ┌────────────────────┐<br>│ ServletOutputStream │─┘     ├─│  DataOutputStream  │<br>└─────────────────────┘       │ └────────────────────┘<br>                              │ ┌────────────────────┐<br>                              └─│CheckedOutputStream │<br>                                └────────────────────┘<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream file = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test.gz&quot;</span>);<br>InputStream buffered = <span class="hljs-keyword">new</span> BufferedInputStream(file);<br>InputStream gzip = <span class="hljs-keyword">new</span> GZIPInputStream(buffered);<br></code></pre></td></tr></table></figure><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>Java的IO标准库使用Filter模式为<code>InputStream</code>和<code>OutputStream</code>增加功能：</p><ul><li>可以把一个<code>InputStream</code>和任意个<code>FilterInputStream</code>组合；</li><li>可以把一个<code>OutputStream</code>和任意个<code>FilterOutputStream</code>组合。</li></ul><p>Filter模式可以在运行期动态增加功能（又称Decorator模式）。</p><hr><h4 id="操作ZIP"><a href="#操作ZIP" class="headerlink" title="操作ZIP"></a>操作ZIP</h4><p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───────────────────┐<br>│    InputStream    │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│ FilterInputStream │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│InflaterInputStream│<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│  ZipInputStream   │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│  JarInputStream   │<br>└───────────────────┘<br></code></pre></td></tr></table></figure><p>另一个<code>JarInputStream</code>是从<code>ZipInputStream</code>派生，它增加的主要功能是直接读取jar文件里面的<code>MANIFEST.MF</code>文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。</p><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>我们要创建一个<code>ZipInputStream</code>，通常是传入一个<code>FileInputStream</code>作为数据源，然后，循环调用<code>getNextEntry()</code>，直到返回<code>null</code>，表示zip流结束。</p><p>一个<code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用<code>read()</code>方法不断读取，直到返回<code>-1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (ZipInputStream zip = <span class="hljs-keyword">new</span> ZipInputStream(<span class="hljs-keyword">new</span> FileInputStream(...))) &#123;<br>    ZipEntry entry = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> ((entry = zip.getNextEntry()) != <span class="hljs-keyword">null</span>) &#123;<br>        String name = entry.getName();<br>        <span class="hljs-keyword">if</span> (!entry.isDirectory()) &#123;<br>            <span class="hljs-keyword">int</span> n;<br>            <span class="hljs-keyword">while</span> ((n = zip.read()) != -<span class="hljs-number">1</span>) &#123;<br>                ...<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="写入zip包"><a href="#写入zip包" class="headerlink" title="写入zip包"></a>写入zip包</h4><p><code>ZipOutputStream</code>是一种<code>FilterOutputStream</code>，它可以直接写入内容到zip包。我们要先创建一个<code>ZipOutputStream</code>，通常是包装一个<code>FileOutputStream</code>，然后，每写入一个文件前，先调用<code>putNextEntry()</code>，然后用<code>write()</code>写入<code>byte[]</code>数据，写入完毕后调用<code>closeEntry()</code>结束这个文件的打包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (ZipOutputStream zip = <span class="hljs-keyword">new</span> ZipOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(...))) &#123;<br>    File[] files = ...<br>    <span class="hljs-keyword">for</span> (File file : files) &#123;<br>        zip.putNextEntry(<span class="hljs-keyword">new</span> ZipEntry(file.getName()));<br>        zip.write(getFileDataAsBytes(file));<br>        zip.closeEntry();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，<code>new ZipEntry(name)</code>传入的<code>name</code>要用相对路径。</p><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p><code>ZipInputStream</code>可以读取zip格式的流，<code>ZipOutputStream</code>可以把多份数据写入zip包；</p><p>配合<code>FileInputStream</code>和<code>FileOutputStream</code>就可以读写zip文件。</p><hr><h4 id="读取ClassPath资源"><a href="#读取ClassPath资源" class="headerlink" title="读取ClassPath资源"></a>读取ClassPath资源</h4><p>很多Java程序启动的时候，都需要读取配置文件。例如，从一个<code>.properties</code>文件中读取配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String conf = <span class="hljs-string">&quot;C:\\conf\\default.properties&quot;</span>;<br><span class="hljs-keyword">try</span> (InputStream input = <span class="hljs-keyword">new</span> FileInputStream(conf)) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码要正常执行，必须在C盘创建<code>conf</code>目录，然后在目录里创建<code>default.properties</code>文件。但是，在Linux系统上，路径和Windows的又不一样。</p><p>因此，从磁盘的固定目录读取配置文件，不是一个好的办法。</p><p>有没有路径无关的读取文件的方式呢？</p><p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把<code>default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p><p>在classpath中的资源文件，路径总是以<code>／</code>开头</p><p>，==我们先获取当前的<code>Class</code>对象，然后调用<code>getResourceAsStream()</code>就可以直接从classpath读取任意的资源文件==：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (InputStream input = getClass().getResourceAsStream(<span class="hljs-string">&quot;/default.properties&quot;</span>)) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，</p><p>如果资源文件不存在，它将返回<code>null</code>。因此，我们需要检查返回的<code>InputStream</code>是否为<code>null</code>，</p><p>如果为<code>null</code>，表示资源文件在classpath中没有找到：</p><hr><p>==这个方法会更好==</p><p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br><br>props.load(inputStreamFromClassPath(<span class="hljs-string">&quot;/default.properties&quot;</span>));<br><br>props.load(inputStreamFromFile(<span class="hljs-string">&quot;./conf.properties&quot;</span>));<br></code></pre></td></tr></table></figure><p>这样读取配置文件，应用程序启动就更加灵活。</p><hr><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>把资源存储在classpath中可以避免文件路径依赖；</p><p><code>Class</code>对象的<code>getResourceAsStream()</code>可以从classpath中读取指定资源；</p><p>根据classpath读取资源时，需要检查返回的<code>InputStream</code>是否为<code>null</code>。</p><hr><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p><p>为什么要把Java对象序列化呢？因为序列化后可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p><p>有序列化，就有反序列化，即把一个二进制内容（也就是<code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code>byte[]</code>并把它“变回”Java对象。</p><p>我们来看看如何把一个Java对象序列化。</p><p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Serializable</code>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteArrayOutputStream buffer = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        <span class="hljs-keyword">try</span> (ObjectOutputStream output = <span class="hljs-keyword">new</span> ObjectOutputStream(buffer)) &#123;<br>            <span class="hljs-comment">// 写入int:</span><br>            output.writeInt(<span class="hljs-number">12345</span>);<br>            <span class="hljs-comment">// 写入String:</span><br>            output.writeUTF(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            <span class="hljs-comment">// 写入Object:</span><br>            output.writeObject(Double.valueOf(<span class="hljs-number">123.456</span>));<br>        &#125;<br>        System.out.println(Arrays.toString(buffer.toByteArray()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p><p>因为写入<code>Object</code>时需要大量的类型信息，所以写入的内容很大。</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (ObjectInputStream input = <span class="hljs-keyword">new</span> ObjectInputStream(...)) &#123;<br>    <span class="hljs-keyword">int</span> n = input.readInt();<br>    String s = input.readUTF();<br>    Double d = (Double) input.readObject();<br>&#125;<br></code></pre></td></tr></table></figure><p>除了能读取基本类型和<code>String</code>类型外，调用<code>readObject()</code>可以直接返回一个<code>Object</code>对象。要把它变成一个特定类型，必须强制转型。</p><p><code>readObject()</code>可能抛出的异常有：</p><ul><li><code>ClassNotFoundException</code>：没有找到对应的Class；<ul><li>例如，<code>Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义<code>Person</code>类，所以无法反序列化。</li></ul></li><li><code>InvalidClassException</code>：Class不匹配。<ul><li><code>Person</code>对象定义了一个<code>int</code>类型的<code>age</code>字段，但是反序列化时，<code>Person</code>类定义的<code>age</code>字段被改成了<code>long</code>类型，所以导致class不兼容。</li></ul></li></ul><p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">2709425275741743919L</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>因为Java的序列化机制可以导致一个实例能直接从<code>byte[]</code>数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的<code>byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p><p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>可序列化的Java对象必须实现<code>java.io.Serializable</code>接口，类似<code>Serializable</code>这样的空接口被称为“标记接口”（Marker Interface）；</p><p>反序列化时不调用构造方法，可设置<code>serialVersionUID</code>作为版本号（非必需）；</p><p>Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。</p><hr><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p><table><thead><tr><th align="left">InputStream</th><th align="left">Reader</th></tr></thead><tbody><tr><td align="left">字节流，以<code>byte</code>为单位</td><td align="left">字符流，以<code>char</code>为单位</td></tr><tr><td align="left">读取字节（-1，0~255）：<code>int read()</code></td><td align="left">读取字符（-1，0~65535）：<code>int read()</code></td></tr><tr><td align="left">读到字节数组：<code>int read(byte[] b)</code></td><td align="left">读到字符数组：<code>int read(char[] c)</code></td></tr></tbody></table><p><code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br></code></pre></td></tr></table></figure><p>这个方法读取字符流的下一个字符，并返回字符表示的<code>int</code>，范围是<code>0</code>~`65535<code>。如果已读到末尾，返回</code>-1`。</p><h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><p><code>FileReader</code>是<code>Reader</code>的一个子类，它可以打开文件并获取<code>Reader</code>。下面的代码演示了如何完整地读取一个<code>FileReader</code>的所有字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 创建一个FileReader对象:</span><br>    Reader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;src/readme.txt&quot;</span>); <span class="hljs-comment">// 字符编码是???</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> n = reader.read(); <span class="hljs-comment">// 反复调用read()方法，直到返回-1</span><br>        <span class="hljs-keyword">if</span> (n == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        System.out.println((<span class="hljs-keyword">char</span>)n); <span class="hljs-comment">// 打印char</span><br>    &#125;<br>    reader.close(); <span class="hljs-comment">// 关闭流</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要避免乱码问题，我们需要在创建<code>FileReader</code>时指定编码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Reader reader = <span class="hljs-keyword">new</span> <span class="hljs-type">FileReader</span>(<span class="hljs-string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure><p><code>Reader</code>还提供了一次性读取若干字符并填充到<code>char[]</code>数组的方法：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">read</span>(<span class="hljs-keyword">char</span>[] c) <span class="hljs-keyword">throws</span> IOException<br></code></pre></td></tr></table></figure><p>它返回实际读入的字符个数，最大不超过<code>char[]</code>数组的长度。返回<code>-1</code>表示流结束。</p><p>利用这个方法，我们可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span> (Reader reader = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;<br>        <span class="hljs-keyword">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1000</span>];<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">while</span> ((n = reader.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;read &quot;</span> + n + <span class="hljs-string">&quot; chars.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h4><p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> (Reader reader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CharArrayReader(<span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-params">toCharArray</span>()</span>)) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h4><p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">try</span> (Reader reader = <span class="hljs-keyword">new</span> <span class="hljs-type">StringReader</span>(<span class="hljs-string">&quot;Hello&quot;</span>)) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p><code>Reader</code>和<code>InputStream</code>有什么关系？</p><p>除了特殊的<code>CharArrayReader</code>和<code>StringReader</code>，普通的<code>Reader</code>实际上是基于<code>InputStream</code>构造的，因为<code>Reader</code>需要从<code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为<code>char</code>就可以实现字符流。如果我们查看<code>FileReader</code>的源码，它在内部实际上持有一个<code>FileInputStream</code>。</p><p>既然<code>Reader</code>本质上是一个基于<code>InputStream</code>的<code>byte</code>到<code>char</code>的转换器，那么，如果我们已经有一个<code>InputStream</code>，想把它转换为<code>Reader</code>，是完全可行的。<code>InputStreamReader</code>就是这样一个转换器，它可以把任何<code>InputStream</code>转换为<code>Reader</code>。示例代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 持有InputStream:</span><br>InputStream input = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileInputStream(<span class="hljs-string">&quot;src/readme.txt&quot;</span>)</span>;<br><span class="hljs-comment">// 变换为Reader:</span><br>Reader reader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">InputStreamReader(<span class="hljs-params">input</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>构造<code>InputStreamReader</code>时，我们需要传入<code>InputStream</code>，还需要指定编码，就可以得到一个<code>Reader</code>对象。上述代码可以通过<code>try (resource)</code>更简洁地改写如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">try</span> (Reader reader = <span class="hljs-keyword">new</span> <span class="hljs-type">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">FileInputStream</span>(<span class="hljs-string">&quot;src/readme.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>)) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码实际上就是<code>FileReader</code>的一种实现方式</p><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><p><code>Reader</code>定义了所有字符输入流的超类：</p><ul><li><code>FileReader</code>实现了文件字符流输入，使用时需要指定编码；</li><li><code>CharArrayReader</code>和<code>StringReader</code>可以在内存中模拟一个字符流输入。</li></ul><p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p><p>总是使用<code>try (resource)</code>保证<code>Reader</code>正确关闭。</p><hr><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p><code>Reader</code>是带编码转换器的<code>InputStream</code>，它把<code>byte</code>转换为<code>char</code>，而<code>Writer</code>就是带编码转换器的<code>OutputStream</code>，它把<code>char</code>转换为<code>byte</code>并输出。</p><p><code>Writer</code>和<code>OutputStream</code>的区别如下：</p><table><thead><tr><th align="left">OutputStream</th><th align="left">Writer</th></tr></thead><tbody><tr><td align="left">字节流，以<code>byte</code>为单位</td><td align="left">字符流，以<code>char</code>为单位</td></tr><tr><td align="left">写入字节（0~255）：<code>void write(int b)</code></td><td align="left">写入字符（0~65535）：<code>void write(int c)</code></td></tr><tr><td align="left">写入字节数组：<code>void write(byte[] b)</code></td><td align="left">写入字符数组：<code>void write(char[] c)</code></td></tr><tr><td align="left">无对应方法</td><td align="left">写入String：<code>void write(String s)</code></td></tr></tbody></table><p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p><ul><li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li><li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li><li>写入String表示的所有字符：<code>void write(String s)</code>。</li></ul><h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (Writer writer = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;<br>    writer.write(<span class="hljs-string">&#x27;H&#x27;</span>); <span class="hljs-comment">// 写入单个字符</span><br>    writer.write(<span class="hljs-string">&quot;Hello&quot;</span>.toCharArray()); <span class="hljs-comment">// 写入char[]</span><br>    writer.write(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 写入String</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><p>除了<code>CharArrayWriter</code>和<code>StringWriter</code>外，普通的Writer实际上是基于<code>OutputStream</code>构造的，它接收<code>char</code>，然后在内部自动转换成一个或多个<code>byte</code>，并写入<code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的<code>OutputStream</code>转换为<code>Writer</code>的转换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (Writer writer = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;readme.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>)) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码实际上就是<code>FileWriter</code>的一种实现方式。这和上一节的<code>InputStreamReader</code>是一样的。</p><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p><code>Writer</code>定义了所有字符输出流的超类：</p><ul><li><code>FileWriter</code>实现了文件字符流输出；</li><li><code>CharArrayWriter</code>和<code>StringWriter</code>在内存中模拟一个字符流输出。</li></ul><p>使用<code>try (resource)</code>保证<code>Writer</code>正确关闭。</p><p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码。</p><hr><h4 id="printStream"><a href="#printStream" class="headerlink" title="printStream"></a>printStream</h4><p><code>PrintStream</code>是一种能接收各种数据类型的输出，打印数据时比较方便：</p><ul><li><code>System.out</code>是标准输出；</li><li><code>System.err</code>是标准错误输出。</li></ul><p><code>PrintWriter</code>是基于<code>Writer</code>的输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(<span class="hljs-number">12345</span>); <span class="hljs-comment">// 输出12345</span><br>System.out.print(<span class="hljs-keyword">new</span> Object()); <span class="hljs-comment">// 输出类似java.lang.Object@3c7a835a</span><br>System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 输出Hello并换行</span><br></code></pre></td></tr></table></figure><h4 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h4><p><code>PrintStream</code>最终输出的总是byte数据，而<code>PrintWriter</code>则是扩展了<code>Writer</code>接口，它的<code>print()</code>/<code>println()</code>方法最终输出的是<code>char</code>数据。两者的使用方法几乎是一模一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>     </span>&#123;<br>        StringWriter buffer = <span class="hljs-keyword">new</span> StringWriter();<br>        <span class="hljs-keyword">try</span> (PrintWriter pw = <span class="hljs-keyword">new</span> PrintWriter(buffer)) &#123;<br>            pw.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            pw.println(<span class="hljs-number">12345</span>);<br>            pw.println(<span class="hljs-keyword">true</span>);<br>        &#125;<br>        System.out.println(buffer.toString());<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="Files的使用"><a href="#Files的使用" class="headerlink" title="Files的使用"></a>Files的使用</h4><p>从Java 7开始，提供了<code>Files</code>和<code>Paths</code>这两个工具类，能极大地方便我们读写文件。</p><p>虽然<code>Files</code>和<code>Paths</code>是<code>java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个<code>byte[]</code>，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] data = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>));<br></code></pre></td></tr></table></figure><p>如果是文本文件，可以把一个文件的全部内容读取为<code>String</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认使用UTF-8编码读取:</span><br>String content1 = Files.readString(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>));<br><span class="hljs-comment">// 可指定编码:</span><br>String content2 = Files.readString(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>), StandardCharsets.ISO_8859_1);<br><span class="hljs-comment">// 按行读取并返回每行内容:</span><br>List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>));<br></code></pre></td></tr></table></figure><p>写入文件也非常方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写入二进制文件:</span><br><span class="hljs-keyword">byte</span>[] data = ...<br>Files.write(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>), data);<br><span class="hljs-comment">// 写入文本并指定编码:</span><br>Files.writeString(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>), <span class="hljs-string">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);<br><span class="hljs-comment">// 按行写入文本:</span><br>List&lt;String&gt; lines = ...<br>Files.write(Paths.get(<span class="hljs-string">&quot;/path/to/file.txt&quot;</span>), lines);<br></code></pre></td></tr></table></figure><p>此外，<code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p><p>最后需要特别注意的是，<code>Files</code>提供的读写方法，受内存限制，==只能读写小文件==，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><p>对于简单的小文件读写操作，可以使用<code>Files</code>工具类简化代码。</p>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>59螺旋矩阵2</title>
    <link href="/2021/10/10/59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52/"/>
    <url>/2021/10/10/59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52/</url>
    
    <content type="html"><![CDATA[<h2 id="59、螺旋矩阵2"><a href="#59、螺旋矩阵2" class="headerlink" title="59、螺旋矩阵2"></a>59、螺旋矩阵2</h2><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p></blockquote><p><img src="D:\study\typora\截图\实例.png"></p><blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>思路：</strong></p><p>按照上一行—&gt;右一列—-&gt;下一行—–&gt;左一列的思路来做</p><p>用left  right top down来记录上下左右的位置</p><p>每次遍历外一圈之后，上下左右相应增减</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu;<br><br><span class="hljs-keyword">import</span> com.sun.deploy.panel.ITreeNode;<br><span class="hljs-keyword">import</span> sun.security.util.Length;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:吴家旭</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>:2021/3/20 - 19:39</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_59</span>螺旋矩阵2 </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] generataMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-comment">//n*n数组第一个数是1开始的</span><br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//创建一个n*n的二维数组</span><br>        <span class="hljs-keyword">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <span class="hljs-comment">//记录左边，上边，右边，下边移动到哪里了</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> down = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//开始遍历且输出数组</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= down) &#123;<br>            <span class="hljs-comment">//输出上面一行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = left; column &lt;= right; column++) &#123;<br>                array[top][column] = num;<br>                num++;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                1 2 3 4</span><br><span class="hljs-comment">                 */</span><br>            &#125;<br>            <span class="hljs-comment">//输出右边一列</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = top + <span class="hljs-number">1</span>; row &lt;= down; row++) &#123;<br>                array[row][right] = num;<br>                num++;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                5</span><br><span class="hljs-comment">                6</span><br><span class="hljs-comment">                7</span><br><span class="hljs-comment">                 */</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; top &lt; down) &#123;<br>                <span class="hljs-comment">//倒着输出下面一行</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = right - <span class="hljs-number">1</span>; column &gt; left; column--) &#123;<br><br>                    array[down][column] = num;<br>                    num++;<br>                &#125;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                    8</span><br><span class="hljs-comment">                   9</span><br><span class="hljs-comment">                 10</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-comment">//倒着获取左一列</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = down; row &gt; top; row--) &#123;<br>                    array[row][left] = num;<br>                    num++;<br>                &#125;<br>            &#125;<br>            left++;<br>            right--;<br>            top++;<br>            down--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        array = generataMatrix(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] ints : array) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> anInt : ints) &#123;<br>                System.out.print(anInt+<span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>-LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2021/10/09/%E9%9B%86%E5%90%88/"/>
    <url>/2021/10/09/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="Java集合简介"><a href="#Java集合简介" class="headerlink" title="Java集合简介"></a>Java集合简介</h3><p>什么是集合（Collection）？</p><ul><li>集合就是”由若干个确定的元素所构成的整体”</li></ul><p>在数学中，我们经常遇到集合的概念。例如：</p><ul><li>有限集合：<ul><li>一个班所有的同学构成的集合；</li><li>一个网站所有的商品构成的集合；</li><li>…</li></ul></li><li>无限集合：<ul><li>全体自然数集合：1，2，3，……</li><li>有理数集合；</li><li>实数集合；</li><li>…</li></ul></li></ul><p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，<strong>Java的数组可以看作是一种集合：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] ss = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 可以持有10个String对象</span><br>ss[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 可以放入String对象</span><br>String first = ss[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 可以获取String对象</span><br></code></pre></td></tr></table></figure><p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？<strong>这是因为数组有如下限制：</strong></p><ul><li><strong>数组初始化后大小不可变</strong></li><li><strong>数组只能按索引顺序存取</strong></li></ul><p>因此我们需要各种不同类型的集合类来处理不同的数据，例如：</p><ul><li>可变大小的顺序链表</li><li>保证无重复元素的集合</li><li>…</li></ul><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><p>Java标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是除==<code>Map</code>==外所有其他集合类的根接口。</p><p>java的<code>java.util</code>包主要提供了以下三种类型的集合：</p><ul><li><code>list</code>：一种有序列表的集合，例如，按索引排列的 <code>student</code>的 <code>List</code>；</li><li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的 <code>student</code>的 <code>Set</code>；</li><li><code>Map</code>：一种通过健值（key-value）查找的映射表集合，例如，根据 <code>student</code>的 <code>name</code>查找对应 <code>student</code>的 <code>Map</code>；</li></ul><p>java集合的设计的几个特点：</p><ul><li><p>一是实现了接口和实现类相分离</p><ul><li>例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等</li></ul></li><li><p>二是支持泛型</p><ul><li><p>我们可以限制在一个集合中只能放入同一种数据类型的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <span class="hljs-comment">// 只能放入String类型</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现</p><ul><li>它最明显的好处在于==无需知道集合内部元素是按什么方式存储的==。</li></ul></li></ul><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p><ul><li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li><li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li><li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li></ul><p>还有一小部分接口是遗留接口，也不应该继续使用：</p><ul><li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Java的集合类定义在<code>java.util</code>包中，支持泛型，主要提供了3种集合类，包括<code>List</code>，<code>Set</code>和<code>Map</code>。Java集合使用统一的<code>Iterator</code>遍历，尽量不要使用遗留接口。</p><h4 id="使用List"><a href="#使用List" class="headerlink" title="使用List"></a>使用List</h4><p>在集合类中，<code>List</code>是最基础的一种集合：它是一种==有序==列表。</p><p>==<code>List</code>的行为和数组几乎完全相同==：<code>List</code>内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，<code>List</code>的索引和数组一样，从<code>0</code>开始。</p><p>数组和<code>List</code>类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组<code>&#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;&#125;</code>中删除索引为<code>2</code>的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ C │ D │ E │   │<br>└───┴───┴───┴───┴───┴───┘<br>              │   │<br>          ┌───┘   │<br>          │   ┌───┘<br>          │   │<br>          ▼   ▼<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ D │ E │   │   │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>这个“删除”操作实际上是把<code>&#39;C&#39;</code>后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦。</p><p>因此，在实际应用中，==<strong>需要增删元素的有序列表，我们使用最多的是<code>ArrayList</code></strong>==。实际上，<code>ArrayList</code>在内部使用了数组来存储所有元素。例如，一个<code>ArrayList</code>拥有5个元素，<strong>实际数组大小为<code>6</code>（即有一个空位</strong>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size&#x3D;5<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ C │ D │ E │   │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>当添加一个元素并指定索引到<code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size&#x3D;5<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │   │ C │ D │ E │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>然后，往内部指定索引的数组位置添加一个元素，然后把<code>size</code>加<code>1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size&#x3D;6<br>┌───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │<br>└───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>继续添加元素，但是数组已满，没有空闲位置的时候，**<code>ArrayList</code>先==创建==一个更大的新数组**，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size&#x3D;6<br>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │   │   │   │   │   │   │<br>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时<code>size</code>加<code>1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ascii">size&#x3D;7<br>┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐<br>│ A │ B │ F │ C │ D │ E │ G │   │   │   │   │   │<br>└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘<br></code></pre></td></tr></table></figure><p>可见，<code>ArrayList</code>把添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动。</p><p>我们考察<code>List&lt;E&gt;</code>接口，可以看到几个主要的接口方法：</p><ul><li>在末尾添加一个元素： <code>boolean add(E e)</code></li><li>在指定索引添加一个元素： <code>boolean add(int index, E e)</code></li><li>删除指定索引的元素： <code>E remove(int index)</code></li><li>删除某个元素： <code>boolean remove(Object e)</code></li><li>获取指定索引的元素：<code>E get(int index)</code></li><li>获取链表的大小(包括元素的个数)： <code>int  size()</code></li></ul><p>但是，实现<code>List</code>接口并非只能通过数组（即<code>ArrayList</code>的实现方式）来实现，==<strong>另一种<code>LinkedList</code>通过“链表”也实现了List接口</strong>==。在<code>LinkedList</code>中，它的内部每个元素都指向下一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ascii">        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐<br>HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │<br>        └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘<br></code></pre></td></tr></table></figure><h4 id="ArrayList和LinkedList的比较"><a href="#ArrayList和LinkedList的比较" class="headerlink" title="ArrayList和LinkedList的比较"></a><code>ArrayList</code>和<code>LinkedList</code>的比较</h4><table><thead><tr><th align="left"></th><th align="left">ArrayList</th><th align="left">LinkedList</th></tr></thead><tbody><tr><td align="left">获取指定元素</td><td align="left">速度很快</td><td align="left">需要从头开始查找元素</td></tr><tr><td align="left">添加元素到末尾</td><td align="left">速度很快</td><td align="left">速度很快</td></tr><tr><td align="left">在指定位置添加/删除</td><td align="left">需要移动元素</td><td align="left">不需要移动元素</td></tr><tr><td align="left">内存占用</td><td align="left">少</td><td align="left">较大</td></tr></tbody></table><p>==通常情况下，我们总是优先使用<code>ArrayList</code>==。</p><h4 id="List的特点"><a href="#List的特点" class="headerlink" title="List的特点"></a>List的特点</h4><p>使用<code>List</code>时，我们要关注<code>List</code>接口的规范。</p><ul><li><p><code>List</code>接口允许我们添加重复的元素，即<code>List</code>内部的元素可以重复：</p></li><li><p><code>List</code>还允许添加<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// size=1</span><br>        list.add(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// size=2</span><br>        list.add(<span class="hljs-string">&quot;pear&quot;</span>); <span class="hljs-comment">// size=3</span><br>        String second = list.get(<span class="hljs-number">1</span>); <span class="hljs-comment">// null</span><br>        System.out.println(second);<br></code></pre></td></tr></table></figure></li></ul><h4 id="创建List"><a href="#创建List" class="headerlink" title="创建List"></a>创建List</h4><p>除了使用<code>ArrayList</code>和<code>LinkedList</code>，我们还可以通过<code>List</code>接口提供的<code>of()</code>方法，根据给定元素快速创建<code>List</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>但是<code>List.of()</code>方法不接受<code>null</code>值，如果传入<code>null</code>，会抛出<code>NullPointerException</code>异常。</p><h4 id="遍历List"><a href="#遍历List" class="headerlink" title="遍历List"></a>遍历List</h4><p>和数组类型，我们要遍历一个<code>List</code>，完全可以用<code>for</code>循环根据索引配合<code>get(int)</code>方法遍历：</p><p>但这种方式并不推荐，一是代码复杂，二是因为<code>get(int)</code>方法只有<code>ArrayList</code>的实现是高效的，换成<code>LinkedList</code>后，索引越大，访问速度越慢。</p><p>==所以我们要始终坚持使用迭代器<code>Iterator</code>来访问<code>List</code>。==</p><p><code>Iterator</code>本身也是一个对象，但它是由<code>List</code>的实例调用<code>iterator()</code>方法的时候创建的。</p><p><code>Iterator</code>对象知道如何遍历一个<code>List</code>，并且不同的<code>List</code>类型，返回的<code>Iterator</code>对象实现也是不同的，但总是具有最高的访问效率。</p><p><code>Iterator</code>对象有两个方法：</p><ul><li><p><code>boolean hasNext()</code>判断是否有下一个元素，</p></li><li><p><code>E next()</code>返回下一个元素。</p><p>因此，使用<code>Iterator</code>遍历<code>List</code>代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>            String s = it.next();<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有童鞋可能觉得使用<code>Iterator</code>访问<code>List</code>的代码比使用索引更复杂。但是，要记住，==通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式==。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。把上面的代码再改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : list) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就是我们编写遍历<code>List</code>的常见代码。</p><p>实际上，只要实现了<code>Iterable</code>接口的集合类都可以直接用<code>for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把<code>for each</code>循环变成<code>Iterator</code>的调用，==原因就在于<code>Iterable</code>接口定义了一个<code>Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个<code>Iterator</code>实例。==</p><h4 id="List-和Array转换"><a href="#List-和Array转换" class="headerlink" title="List 和Array转换"></a>List 和Array转换</h4><p>把 <code>List</code> 变为 <code>Array</code>有三种方法</p><ul><li><p>第一种是调用<code>toArray()</code>方法直接返回一个<code>Object[]</code>数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>        Object[] array = list.toArray();<br>        <span class="hljs-keyword">for</span> (Object s : array) &#123;<br>            System.out.println(s);<br>        &#125;<br><br><span class="hljs-comment">//这种方法会丢失类型信息，所以实际应用很少</span><br></code></pre></td></tr></table></figure></li><li><p>第二种方式是给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br>Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>注意到这个<code>toArray(T[])</code>方法的泛型参数<code>&lt;T&gt;</code>并不是<code>List</code>接口定义的泛型参数<code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组，例如我们传入<code>Number</code>类型的数组，返回的仍然是<code>Number</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Number[] array = list.toArray(<span class="hljs-keyword">new</span> Number[<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>但是，如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于<code>List</code>的元素是<code>Integer</code>，所以无法放入<code>String</code>数组，这个方法会抛出<code>ArrayStoreException</code>。</p><p>如果我们传入的数组大小和<code>List</code>实际的元素个数不一致怎么办？根据<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/List.html#toArray(T[])">List接口</a>的文档，我们可以知道：</p><p><strong>如果传入的数组不够大，那么<code>List</code>内部会创建一个新的刚好够大的数组</strong>，填充后返回；</p><p><strong>如果传入的数组比<code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充<code>null</code>。</strong></p><p>实际上，最常用的是传入一个“恰好”大小的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[list.size()]);<br></code></pre></td></tr></table></figure></li><li><p><strong>最后一种更简洁的写法是通过<code>List</code>接口定义的<code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] array = list.toArray(Integer[]::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure></li></ul><p>反过来，把<code>Array</code>变为<code>List</code>就简单多了，通过<code>List.of(T...)</code>方法最简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] array = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List&lt;Integer&gt; list = List.of(array);<br></code></pre></td></tr></table></figure><p>对于JDK 11之前的版本，==可以使用<code>Arrays.asList(T...)</code>方法把数组转换成<code>List</code>。==</p><p>要注意的是，返回的<code>List</code>不一定就是<code>ArrayList</code>或者<code>LinkedList</code>，因为<code>List</code>只是一个接口，如果我们调用<code>List.of()</code>，它返回的是一个只读<code>List</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = List.of(<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">56</span>);<br>        list.add(<span class="hljs-number">999</span>); <span class="hljs-comment">// UnsupportedOperationException</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><code>List</code>是按索引顺序访问的长度可变的有序表，优先使用<code>ArrayList</code>而不是<code>LinkedList</code>；</p><p>可以直接使用<code>for each</code>遍历<code>List</code>；</p><p><code>List</code>可以和<code>Array</code>相互转换。</p><h4 id="编写equals"><a href="#编写equals" class="headerlink" title="编写equals"></a>编写equals</h4><p>如何正确编写<code>equals()</code>方法？<code>equals()</code>方法要求我们必须满足以下条件：</p><ul><li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li><li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li><li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li><li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li><li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li></ul><p>上述规则看上去似乎非常复杂，但其实代码实现<code>equals()</code>方法是很简单的，我们以<code>Person</code>类为例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，我们要定义“相等”的逻辑含义。对于<code>Person</code>类，如果<code>name</code>相等，并且<code>age</code>相等，我们就认为两个<code>Person</code>实例相等。</p><p>因此，编写<code>equals()</code>方法如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        Person p = (Person) o;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="hljs-built_in">this</span>.age == p.age;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于引用字段比较，我们使用<code>equals()</code>，对于基本类型字段的比较，我们使用<code>==</code>。</p><p>如果<code>this.name</code>为<code>null</code>，那么<code>equals()</code>方法会报错，因此，需要继续改写如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> boolean equals(Object o) &#123;<br>    <span class="hljs-keyword">if</span> (o instanceof Person) &#123;<br>        Person p = (Person) o;<br>        boolean nameEquals = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name == <span class="hljs-literal">null</span> &amp;&amp; p.name == <span class="hljs-literal">null</span>) &#123;<br>            nameEquals = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name != <span class="hljs-literal">null</span>) &#123;<br>            nameEquals = <span class="hljs-keyword">this</span>.name.equals(p.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nameEquals &amp;&amp; <span class="hljs-keyword">this</span>.age == p.age;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果<code>Person</code>有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用<code>Objects.equals()</code>静态方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        Person p = (Person) o;<br>        <span class="hljs-keyword">return</span> Objects.equals(<span class="hljs-built_in">this</span>.name, p.name) &amp;&amp; <span class="hljs-built_in">this</span>.age == p.age;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们总结一下<code>equals()</code>方法的正确编写方法：</p><ol><li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li><li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li><li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li></ol><p>使用<code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断<code>null</code>的麻烦。两个引用类型都是<code>null</code>时它们也是相等的。</p><p>如果不调用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，那么放入的元素就不需要实现<code>equals()</code>方法。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>在<code>List</code>中查找元素时，<code>List</code>的实现类通过元素的<code>equals()</code>方法比较两个元素是否相等，因此，放入的元素必须正确覆写<code>equals()</code>方法，Java标准库提供的<code>String</code>、<code>Integer</code>等已经覆写了<code>equals()</code>方法；</p><p>编写<code>equals()</code>方法可借助<code>Objects.equals()</code>判断。</p><p>如果不在<code>List</code>中查找元素，就不必覆写<code>equals()</code>方法。</p><h4 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h4><p>我们知道，<code>List</code>是一种顺序列表，如果有一个存储学生<code>Student</code>实例的<code>List</code>，要在<code>List</code>中根据<code>name</code>查找某个指定的<code>Student</code>的分数，应该怎么办？</p><p>最简单的方法是遍历<code>List</code>并判断<code>name</code>是否相等，然后返回指定元素：</p><p>这种需求其实非常常见，即通过一个键去查询对应的值。使用<code>List</code>来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而<code>Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code>key</code>快速查找<code>value</code>（元素）。</p><p>用<code>Map</code>来实现根据<code>name</code>查询某个<code>Student</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, <span class="hljs-number">99</span>);<br>        Map&lt;String, Student&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;Xiao Ming&quot;</span>, s); <span class="hljs-comment">// 将&quot;Xiao Ming&quot;和Student实例映射并关联</span><br>        Student target = map.get(<span class="hljs-string">&quot;Xiao Ming&quot;</span>); <span class="hljs-comment">// 通过key查找并返回映射的Student实例</span><br>        System.out.println(target == s); <span class="hljs-comment">// true，同一个实例</span><br>        System.out.println(target.score); <span class="hljs-comment">// 99</span><br>        Student another = map.get(<span class="hljs-string">&quot;Bob&quot;</span>); <span class="hljs-comment">// 通过另一个key查找</span><br>        System.out.println(another); <span class="hljs-comment">// 未找到返回null</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> score;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> score)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过上述代码可知：<code>Map&lt;K, V&gt;</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p><p>如果只是想查询某个<code>key</code>是否存在，可以调用<code>boolean containsKey(K key)</code>方法。</p><h4 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h4><p>对<code>Map</code>来说，要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">123</span>);<br>        map.put(<span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-number">456</span>);<br>        map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">789</span>);<br>        <span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;<br>            Integer value = map.get(key);<br>            System.out.println(key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">123</span>);<br>        map.put(<span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-number">456</span>);<br>        map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">789</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;<br>            String key = entry.getKey();<br>            Integer value = entry.getValue();<br>            System.out.println(key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Map</code>和<code>List</code>不同的是，<code>Map</code>存储的是<code>key-value</code>的映射关系，并且，它<em>不保证顺序</em>。在遍历的时候，遍历的顺序既不一定是<code>put()</code>时放入的<code>key</code>的顺序，也不一定是<code>key</code>的排序顺序。使用<code>Map</code>时，任何依赖顺序的逻辑都是不可靠的。以<code>HashMap</code>为例，假设我们放入<code>&quot;A&quot;</code>，<code>&quot;B&quot;</code>，<code>&quot;C&quot;</code>这3个<code>key</code>，遍历的时候，每个<code>key</code>会保证被遍历一次且仅遍历一次，但顺序完全没有保证，甚至对于不同的JDK版本，相同的代码遍历的输出顺序都是不同的！</p><p>==<strong>遍历Map时，不可假设输出的key是有序的！</strong>==</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p><code>Map</code>是一种映射表，可以通过<code>key</code>快速查找<code>value</code>。</p><p>可以通过<code>for each</code>遍历<code>keySet()</code>，也可以通过<code>for each</code>遍历<code>entrySet()</code>，直接获取<code>key-value</code>。</p><p>最常用的一种<code>Map</code>实现是<code>HashMap</code>。</p><h4 id="编写equals和hashCode"><a href="#编写equals和hashCode" class="headerlink" title="编写equals和hashCode"></a>编写equals和hashCode</h4><p>我们知道Map是一种键-值（key-value）映射表，可以通过key快速查找对应的value。</p><p>以HashMap为例，观察下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Person&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Ming&quot;</span>));<br>map.put(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Hong&quot;</span>));<br>map.put(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Jun&quot;</span>));<br><br>map.get(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// Person(&quot;Xiao Ming&quot;)</span><br>map.get(<span class="hljs-string">&quot;x&quot;</span>); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p><code>HashMap</code>之所以能根据<code>key</code>直接拿到<code>value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有<code>value</code>，并根据key直接计算出<code>value</code>应该存储在哪个索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">  ┌───┐<br>0 │   │<br>  ├───┤<br>1 │ ●─┼───&gt; Person(&quot;Xiao Ming&quot;)<br>  ├───┤<br>2 │   │<br>  ├───┤<br>3 │   │<br>  ├───┤<br>4 │   │<br>  ├───┤<br>5 │ ●─┼───&gt; Person(&quot;Xiao Hong&quot;)<br>  ├───┤<br>6 │ ●─┼───&gt; Person(&quot;Xiao Jun&quot;)<br>  ├───┤<br>7 │   │<br>  └───┘<br></code></pre></td></tr></table></figure><p>如果<code>key</code>的值为<code>&quot;a&quot;</code>，计算得到的索引总是<code>1</code>，因此返回<code>value</code>为<code>Person(&quot;Xiao Ming&quot;)</code>，如果<code>key</code>的值为<code>&quot;b&quot;</code>，计算得到的索引总是<code>5</code>，因此返回<code>value</code>为<code>Person(&quot;Xiao Hong&quot;)</code>，这样，就不必遍历整个数组，即可直接读取<code>key</code>对应的<code>value</code>。</p><p>当我们使用<code>key</code>存取<code>value</code>的时候，就会引出一个问题：</p><p>我们放入<code>Map</code>的<code>key</code>是字符串<code>&quot;a&quot;</code>，但是，当我们获取<code>Map</code>的<code>value</code>时，传入的变量不一定就是放入的那个<code>key</code>对象。</p><p>换句话讲，==两个<code>key</code>应该是内容相同，但不一定是同一个对象==。测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String key1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(key1, <span class="hljs-number">123</span>);<br><br>        String key2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>);<br>        map.get(key2); <span class="hljs-comment">// 123</span><br><br>        System.out.println(key1 == key2); <span class="hljs-comment">// false</span><br>        System.out.println(key1.equals(key2)); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为在<code>Map</code>的内部，对<code>key</code>做比较是通过<code>equals()</code>实现的，这一点和<code>List</code>查找元素需要正确覆写<code>equals()</code>是一样的，即正确使用<code>Map</code>必须保证：作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法。</p><p>我们经常使用<code>String</code>作为<code>key</code>，因为<code>String</code>已经正确覆写了<code>equals()</code>方法。但如果我们放入的<code>key</code>是一个自己写的类，就必须保证正确覆写了<code>equals()</code>方法。</p><p>==思考一下<code>HashMap</code>为什么能通过<code>key</code>直接计算出<code>value</code>存储的索引==</p><ul><li>相同的<code>key</code>对象（使用<code>equals()</code>判断时返回<code>true</code>）必须要计算出相同的索引，否则，相同的<code>key</code>每次取出的<code>value</code>就不一定对。</li><li>通过<code>key</code>计算索引的方式就是调用<code>key</code>对象的<code>hashCode()</code>方法，它返回一个<code>int</code>整数。<code>HashMap</code>正是通过这个方法直接定位<code>key</code>对应的<code>value</code>的索引，继而直接返回<code>value</code>。</li></ul><p>因此，正确使用<code>Map</code>必须保证：</p><ol><li>==作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法==，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li><li>==作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法==，且<code>hashCode()</code>方法要严格遵循以下规范：</li></ol><ul><li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li><li>如果两个对象不相等，则两个对象的<code>hashCode()</code>==尽量==不要相等。</li></ul><p>上述第一条规范是正确性，必须保证实现，否则<code>HashMap</code>不能正常工作。</p><p>而==第二条如果尽量满足，则可以保证查询效率==，因为不同的对象，如果返回相同的<code>hashCode()</code>，会造成<code>Map</code>内部存储冲突，使存取的效率下降。</p><p>注意到<code>String</code>类已经正确实现了<code>hashCode()</code>方法，我们在计算<code>Person</code>的<code>hashCode()</code>时，反复使用<code>31*h</code>，这样做的目的是为了尽量把不同的<code>Person</code>实例的<code>hashCode()</code>均匀分布到整个<code>int</code>范围。</p><p>和实现<code>equals()</code>方法遇到的问题类似，如果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。为了解决这个问题，我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Objects.hash(firstName, lastName, age);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</p><ul><li><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；</li><li><code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</li></ul><p>另外注意，对于放入<code>HashMap</code>的<code>value</code>对象，没有任何要求。</p><h4 id="关于hashMap"><a href="#关于hashMap" class="headerlink" title="关于hashMap"></a>关于hashMap</h4><p>==实际上<code>HashMap</code>初始化时默认的数组大小只有16，任何<code>key</code>，无论它的<code>hashCode()</code>有多大，都可以简单地通过：==</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> index = key.hashCode() &amp; <span class="hljs-number">0</span>xf; // <span class="hljs-number">0</span>xf = <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>把索引确定在0～15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p><p>第二个问题：如果添加超过16个<code>key-value</code>到<code>HashMap</code>，数组不够用了怎么办？</p><p>添加超过一定数量的<code>key-value</code>时，==<code>HashMap</code>会在内部自动扩容==，每次扩容一倍，即==长度为16的数组扩展为长度32==，相应地，需要重新确定<code>hashCode()</code>计算的索引位置。例如，对长度为32的数组计算<code>hashCode()</code>对应的索引，计算方式要改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> index = key.hashCode() &amp; <span class="hljs-number">0x1f</span>; <span class="hljs-comment">// 0x1f = 31</span><br></code></pre></td></tr></table></figure><p>由于扩容会导致重新分布已有的<code>key-value</code>，所以，频繁扩容对<code>HashMap</code>的性能影响很大。如果我们确定要使用一个容量为<code>10000</code>个<code>key-value</code>的<code>HashMap</code>，更好的方式是==创建<code>HashMap</code>时就指定容量==：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure><p>虽然指定容量是<code>10000</code>，但==<code>HashMap</code>内部的数组长度总是2<sup>n</sup>==，因此，实际数组长度被初始化为比<code>10000</code>大的<code>16384</code>（2<sup>14</sup>）。</p><p>最后一个问题：如果不同的两个<code>key</code>，例如<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>，它们的<code>hashCode()</code>恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求<code>hashCode()</code>尽量不相等），那么，当我们放入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">map.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Ming&quot;</span>));<br>map.put(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Xiao Hong&quot;</span>));<br></code></pre></td></tr></table></figure><p>时，由于计算出的数组索引相同，后面放入的<code>&quot;Xiao Hong&quot;</code>会不会把<code>&quot;Xiao Ming&quot;</code>覆盖了？</p><ul><li>HashMap内部通过<code>&quot;a&quot;</code>找到的实际上是<code>List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个<code>List</code>，并找到一个<code>Entry</code>，它的<code>key</code>字段是<code>&quot;a&quot;</code>，才能返回对应的<code>Person</code>实例。</li></ul><p>我们把不同的<code>key</code>具有相同的<code>hashCode()</code>的情况称之为==哈希冲突==</p><p><code>hashCode()</code>方法编写得越好，<code>HashMap</code>工作的效率就越高。</p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>要正确使用<code>HashMap</code>，作为<code>key</code>的类必须正确覆写<code>equals()</code>和<code>hashCode()</code>方法；</p><p>一个类如果覆写了<code>equals()</code>，就必须覆写<code>hashCode()</code>，并且覆写规则是：</p><ul><li>如果<code>equals()</code>返回<code>true</code>，则<code>hashCode()</code>返回值必须相等；</li><li>如果<code>equals()</code>返回<code>false</code>，则<code>hashCode()</code>返回值尽量不要相等。</li></ul><p>实现<code>hashCode()</code>方法可以通过<code>Objects.hashCode()</code>辅助方法实现。</p><h4 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h4><hr><p>因为<code>HashMap</code>是一种通过对key计算<code>hashCode()</code>，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。</p><p>如果作为key的对象是<code>enum</code>类型，那么，还可以使用Java集合库提供的一种<code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p><p>我们以<code>DayOfWeek</code>这个枚举类型为例，为它做一个“翻译”功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.DayOfWeek;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;DayOfWeek, String&gt; map = <span class="hljs-keyword">new</span> EnumMap&lt;&gt;(DayOfWeek.class);<br>        map.put(DayOfWeek.MONDAY, <span class="hljs-string">&quot;星期一&quot;</span>);<br>        map.put(DayOfWeek.TUESDAY, <span class="hljs-string">&quot;星期二&quot;</span>);<br>        map.put(DayOfWeek.WEDNESDAY, <span class="hljs-string">&quot;星期三&quot;</span>);<br>        map.put(DayOfWeek.THURSDAY, <span class="hljs-string">&quot;星期四&quot;</span>);<br>        map.put(DayOfWeek.FRIDAY, <span class="hljs-string">&quot;星期五&quot;</span>);<br>        map.put(DayOfWeek.SATURDAY, <span class="hljs-string">&quot;星期六&quot;</span>);<br>        map.put(DayOfWeek.SUNDAY, <span class="hljs-string">&quot;星期日&quot;</span>);<br>        System.out.println(map);<br>        System.out.println(map.get(DayOfWeek.MONDAY));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>EnumMap</code>的时候，我们总是用<code>Map</code>接口来引用它，因此，实际上把<code>HashMap</code>和<code>EnumMap</code>互换，在客户端看来没有任何区别.</p><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code>，既保证速度，也不浪费空间。</p><p>使用<code>EnumMap</code>的时候，根据面向抽象编程的原则，应持有<code>Map</code>接口。</p><h4 id="使用TreeMap"><a href="#使用TreeMap" class="headerlink" title="使用TreeMap"></a>使用TreeMap</h4><hr><p>我们已经知道，<code>HashMap</code>是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历<code>HashMap</code>的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。</p><p>还有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<code>SortedMap</code>。注意到<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ascii">       ┌───┐<br>       │Map│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashMap│ │SortedMap│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ TreeMap │<br>          └─────────┘<br></code></pre></td></tr></table></figure><p><code>SortedMap</code>保证遍历时以Key的顺序来进行排序。例如，放入的Key是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;orange&quot;</code>，遍历的顺序一定是<code>&quot;apple&quot;</code>、<code>&quot;orange&quot;</code>、<code>&quot;pear&quot;</code>，因为<code>String</code>默认按字母排序：</p><p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。</p><p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;Person, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person p1, Person p2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> p1.name.compareTo(p2.name);<br>            &#125;<br>        &#125;);<br>        map.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Tom&quot;</span>), <span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>), <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>), <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (Person key : map.keySet()) &#123;<br>            System.out.println(key);<br>        &#125;<br>        <span class="hljs-comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span><br>        System.out.println(map.get(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>))); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    Person(String name) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;Person: &quot;</span> + name + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到<code>Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code>a</code>和<code>b</code>，如果<code>a&lt;b</code>，则返回负数，通常是<code>-1</code>，如果<code>a==b</code>，则返回<code>0</code>，如果<code>a&gt;b</code>，则返回正数，通常是<code>1</code>。<code>TreeMap</code>内部根据比较结果对Key进行排序。</p><p>从上述代码执行结果可知，打印的Key确实是按照<code>Comparator</code>定义的顺序排序的。如果要根据Key查找Value，我们可以传入一个<code>new Person(&quot;Bob&quot;)</code>作为Key，它会返回对应的<code>Integer</code>值<code>2</code>。</p><p>另外，注意到<code>Person</code>类并未覆写<code>equals()</code>和<code>hashCode()</code>，因为<code>TreeMap</code>不使用<code>equals()</code>和<code>hashCode()</code>。</p><p>我们来看一个稍微复杂的例子：这次我们定义了<code>Student</code>类，并用分数<code>score</code>进行排序，高分在前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;Student, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Student&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student p1, Student p2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>        map.put(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">77</span>), <span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">66</span>), <span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">99</span>), <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (Student key : map.keySet()) &#123;<br>            System.out.println(key);<br>        &#125;<br>        System.out.println(map.get(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">66</span>))); <span class="hljs-comment">// null?</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> score;<br>    Student(String name, <span class="hljs-keyword">int</span> score) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.score = score;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;&#123;%s: score=%d&#125;&quot;</span>, name, score);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>for</code>循环中，我们确实得到了正确的顺序。但是，且慢！根据相同的Key：<code>new Student(&quot;Bob&quot;, 66)</code>进行查找时，结果为<code>null</code>！</p><p>这是怎么肥四？难道<code>TreeMap</code>有问题？遇到<code>TreeMap</code>工作不正常时，我们首先回顾Java编程基本规则：出现问题，不要怀疑Java标准库，要从自身代码找原因。</p><p>在这个例子中，<code>TreeMap</code>出现问题，原因其实出在这个<code>Comparator</code>上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student p1, Student p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>p1.score</code>和<code>p2.score</code>不相等的时候，它的返回值是正确的，但是，在<code>p1.score</code>和<code>p2.score</code>相等的时候，它并没有返回<code>0</code>！这就是为什么<code>TreeMap</code>工作不正常的原因：<code>TreeMap</code>在比较两个Key是否相等时，依赖Key的<code>compareTo()</code>方法或者<code>Comparator.compare()</code>方法。在两个Key相等时，必须返回<code>0</code>。因此，修改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student p1, Student p2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p1.score == p2.score) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1.score &gt; p2.score ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者直接借助<code>Integer.compare(int, int)</code>也可以返回正确的比较结果。</p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p><code>SortedMap</code>在遍历时严格按照Key的顺序遍历，最常用的实现类是<code>TreeMap</code>；</p><p>作为<code>SortedMap</code>的Key必须实现<code>Comparable</code>接口，或者传入<code>Comparator</code>；</p><p>要严格按照<code>compare()</code>规范实现比较逻辑，否则，<code>TreeMap</code>将不能正常工作。</p><h4 id="配置文件：使用Properties"><a href="#配置文件：使用Properties" class="headerlink" title="配置文件：使用Properties"></a>配置文件：使用Properties</h4><p>在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># 上次最后打开的文件:<br>last_open_file=/data/hello.txt<br># 自动保存文件的时间间隔:<br>auto_save_interval=<span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>配置文件的特点是，它的Key-Value一般都是<code>String</code>-<code>String</code>类型的，因此我们完全可以用<code>Map&lt;String, String&gt;</code>来表示它。</p><p>因为配置文件非常常用，所以Java集合库提供了一个<code>Properties</code>来表示一组“配置”。由于历史遗留原因，<code>Properties</code>内部本质上是一个<code>Hashtable</code>，==但我们只需要用到<code>Properties</code>自身关于读写配置的接口。==</p><h4 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>用<code>Properties</code>读取配置文件非常简单。Java默认配置文件以<code>.properties</code>为扩展名，每行以<code>key=value</code>表示，以<code>#</code>课开头的是注释。以下是一个典型的配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># setting.properties<br><br>last_open_file=/data/hello.txt<br>auto_save_interval=<span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>可以从文件系统读取这个<code>.properties</code>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String f = <span class="hljs-string">&quot;setting.properties&quot;</span>;<br>Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(<span class="hljs-keyword">new</span> java.io.FileInputStream(f));<br><br>String filepath = props.getProperty(<span class="hljs-string">&quot;last_open_file&quot;</span>);<br>String interval = props.getProperty(<span class="hljs-string">&quot;auto_save_interval&quot;</span>, <span class="hljs-string">&quot;120&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>可见，用<code>Properties</code>读取配置文件，一共有三步：</strong></p><ol><li><strong>创建<code>Properties</code>实例；</strong></li><li><strong>调用<code>load()</code>读取文件；</strong></li><li><strong>调用<code>getProperty()</code>获取配置。</strong></li></ol><p>也可以从classpath读取<code>.properties</code>文件，因为<code>load(InputStream)</code>方法接收一个<code>InputStream</code>实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(getClass().getResourceAsStream(<span class="hljs-string">&quot;/common/setting.properties&quot;</span>));<br></code></pre></td></tr></table></figure><p>试试从内存读取一个字节流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String settings = <span class="hljs-string">&quot;# test&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;course=Java&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;last_open_date=2019-08-07T12:35:01&quot;</span>;<br>        ByteArrayInputStream input = <span class="hljs-keyword">new</span> ByteArrayInputStream(settings.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        Properties props = <span class="hljs-keyword">new</span> Properties();<br>        props.load(input);<br><br>        System.out.println(<span class="hljs-string">&quot;course: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;course&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;last_open_date: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;last_open_date&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;last_open_file: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;last_open_file&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;auto_save: &quot;</span> + props.getProperty(<span class="hljs-string">&quot;auto_save&quot;</span>, <span class="hljs-string">&quot;60&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有多个<code>.properties</code>文件，可以反复调用<code>load()</code>读取，后读取的key-value会覆盖已读取的key-value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(getClass().getResourceAsStream(<span class="hljs-string">&quot;/common/setting.properties&quot;</span>));<br>props.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\conf\\setting.properties&quot;</span>));<br></code></pre></td></tr></table></figure><p>上面的代码演示了<code>Properties</code>的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。</p><p><code>Properties</code>设计的目的是存储<code>String</code>类型的key－value，但<code>Properties</code>实际上是从<code>Hashtable</code>派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了<code>getProperty()</code>和<code>setProperty()</code>方法外，还有从<code>Hashtable</code>继承下来的<code>get()</code>和<code>put()</code>方法，这些方法的参数签名是<code>Object</code>，我们在使用<code>Properties</code>的时候，==不要去调用==这些从<code>Hashtable</code>继承下来的方法。</p><h4 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h4><p>如果通过<code>setProperty()</code>修改了<code>Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code>store()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.setProperty(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;http://www.liaoxuefeng.com&quot;</span>);<br>props.setProperty(<span class="hljs-string">&quot;language&quot;</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>props.store(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\conf\\setting.properties&quot;</span>), <span class="hljs-string">&quot;这是写入的properties注释&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>早期版本的Java规定<code>.properties</code>文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用<code>name=\u4e2d\u6587</code>来表示，非常别扭。从JDK9开始，Java的<code>.properties</code>文件可以使用UTF-8编码了。</p><p>不过，需要注意的是，由于<code>load(InputStream)</code>默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法<code>load(Reader)</code>读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props = <span class="hljs-keyword">new</span> Properties();<br>props.load(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));<br></code></pre></td></tr></table></figure><p>就可以正常读取中文。<code>InputStream</code>和<code>Reader</code>的区别是一个是字节流，一个是字符流。字符流在内存中已经以<code>char</code>类型表示了，不涉及编码问题。</p><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>Java集合库提供的<code>Properties</code>用于读写配置文件<code>.properties</code>。<code>.properties</code>文件可以使用UTF-8编码。</p><p>可以从文件系统、classpath或其他任何地方读取<code>.properties</code>文件。</p><p>读写<code>Properties</code>时，注意仅使用<code>getProperty()</code>和<code>setProperty()</code>方法，不要调用继承而来的<code>get()</code>和<code>put()</code>等方法。</p><h4 id="使用Set"><a href="#使用Set" class="headerlink" title="使用Set"></a>使用Set</h4><hr><p>我们知道，<code>Map</code>用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写<code>equals()</code>方法，还要正确覆写<code>hashCode()</code>方法。</p><p>如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用<code>Set</code>。</p><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p><ul><li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li><li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li><li>判断是否包含元素：<code>boolean contains(Object e)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        System.out.println(set.add(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;xyz&quot;</span>)); <span class="hljs-comment">// true</span><br>        System.out.println(set.add(<span class="hljs-string">&quot;xyz&quot;</span>)); <span class="hljs-comment">// false，添加失败，因为元素已存在</span><br>        System.out.println(set.contains(<span class="hljs-string">&quot;xyz&quot;</span>)); <span class="hljs-comment">// true，元素存在</span><br>        System.out.println(set.contains(<span class="hljs-string">&quot;XYZ&quot;</span>)); <span class="hljs-comment">// false，元素不存在</span><br>        System.out.println(set.remove(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// false，删除失败，因为元素不存在</span><br>        System.out.println(set.size()); <span class="hljs-comment">// 2，一共两个元素</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>Set</code>实际上相当于只存储key、不存储value的<code>Map</code>。我们经常用<code>Set</code>用于去除重复元素。</p><p>因为放入<code>Set</code>的元素和<code>Map</code>的key类似，都要正确实现<code>equals()</code>和<code>hashCode()</code>方法，否则该元素无法正确地放入<code>Set</code>。</p><p>最常用的<code>Set</code>实现类是<code>HashSet</code>，实际上，<code>HashSet</code>仅仅是对<code>HashMap</code>的一个简单封装，它的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 持有一个HashMap:</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">// 放入HashMap的value:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT) == <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.containsKey(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.remove(o) == PRESENT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Set</code>接口并不保证有序，而<code>SortedSet</code>接口则保证元素是有序的：</p><ul><li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li><li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li></ul><p>用一张图表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ascii">       ┌───┐<br>       │Set│<br>       └───┘<br>         ▲<br>    ┌────┴─────┐<br>    │          │<br>┌───────┐ ┌─────────┐<br>│HashSet│ │SortedSet│<br>└───────┘ └─────────┘<br>               ▲<br>               │<br>          ┌─────────┐<br>          │ TreeSet │<br>          └─────────┘<br></code></pre></td></tr></table></figure><p>我们来看<code>HashSet</code>的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        set.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;pear&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;orange&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : set) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意输出的顺序既不是添加的顺序，也不是<code>String</code>排序的顺序，在不同版本的JDK中，这个顺序也可能是不同的。</p><p>把<code>HashSet</code>换成<code>TreeSet</code>，在遍历<code>TreeSet</code>时，输出就是有序的，这个顺序是元素的排序顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>        set.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;pear&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;orange&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : set) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>TreeSet</code>和使用<code>TreeMap</code>的要求一样，添加的元素必须正确实现<code>Comparable</code>接口，如果没有实现<code>Comparable</code>接口，那么创建<code>TreeSet</code>时必须传入一个<code>Comparator</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Message&gt; received = List.of(<br>            <span class="hljs-keyword">new</span> Message(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello!&quot;</span>),<br>            <span class="hljs-keyword">new</span> Message(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;发工资了吗？&quot;</span>),<br>            <span class="hljs-keyword">new</span> Message(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;发工资了吗？&quot;</span>),<br>            <span class="hljs-keyword">new</span> Message(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;去哪吃饭？&quot;</span>),<br>            <span class="hljs-keyword">new</span> Message(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;去哪吃饭？&quot;</span>),<br>            <span class="hljs-keyword">new</span> Message(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Bye&quot;</span>)<br>        );<br>        List&lt;Message&gt; displayMessages = process(received);<br>        <span class="hljs-keyword">for</span> (Message message : displayMessages) &#123;<br>            System.out.println(message.text);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> List&lt;Message&gt; <span class="hljs-title">process</span><span class="hljs-params">(List&lt;Message&gt; received)</span> </span>&#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 按sequence去除重复消息</span><br>List&lt;Message&gt; receiveds = <span class="hljs-keyword">new</span> ArrayList&lt;Message&gt;();<br><br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(Message m:received)&#123;<br><br>            <span class="hljs-keyword">if</span>(!set.contains(m.sequence))&#123;<br><br>                set.add(m.sequence);<br><br>                receiveds.add(m);<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> receiveds;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sequence;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String text;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sequence, String text)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sequence = sequence;<br>        <span class="hljs-keyword">this</span>.text = text;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><p><code>Set</code>用于存储不重复的元素集合：</p><ul><li>放入<code>HashSet</code>的元素与作为<code>HashMap</code>的key要求相同；</li><li>放入<code>TreeSet</code>的元素与作为<code>TreeMap</code>的Key要求相同；</li></ul><p>利用<code>Set</code>可以去除重复元素；</p><p>遍历<code>SortedSet</code>按照元素的排序顺序遍历，也可以自定义排序算法。</p><h4 id="使用Queue"><a href="#使用Queue" class="headerlink" title="使用Queue"></a>使用Queue</h4><hr><p>队列（<code>Queue</code>）是一种经常使用的集合。<code>Queue</code>实际上是实现了一个==先进先出==（FIFO：First In First Out）的有序表。</p><p>它和<code>List</code>的区别在于：</p><ul><li><code>List</code>可以在任意位置添加和删除元素</li><li>而<code>Queue</code>只有两个操作：<ul><li>把元素添加到队列末尾；</li><li>从队列头部取出元素。</li></ul></li></ul><p>超市的收银台就是一个队列：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1285667604660289/l" alt="queue"></p><p>在Java的标准库中，队列接口<code>Queue</code>定义了以下几个方法：</p><ul><li><code>int size()</code>：获取队列长度；</li><li><code>boolean add(E)</code>/<code>boolean offer(E)</code>：添加元素到队尾；</li><li><code>E remove()</code>/<code>E poll()</code>：获取队首元素并从队列中删除；</li><li><code>E element()</code>/<code>E peek()</code>：获取队首元素但并不从队列中删除。</li></ul><p>对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p><table><thead><tr><th align="left"></th><th align="left">throw Exception</th><th align="left">返回false或null</th></tr></thead><tbody><tr><td align="left">添加元素到队尾</td><td align="left">add(E e)</td><td align="left">boolean offer(E e)</td></tr><tr><td align="left">取队首元素并删除</td><td align="left">E remove()</td><td align="left">E poll()</td></tr><tr><td align="left">取队首元素但不删除</td><td align="left">E element()</td><td align="left">E peek()</td></tr></tbody></table><p>举个栗子，假设我们有一个队列，对它做一个添加操作，如果调用<code>add()</code>方法，当添加失败时（可能超过了队列的容量），它会抛出异常：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing">Queue&lt;<span class="hljs-keyword">String</span>&gt; q = ...<br><span class="hljs-keyword">try</span> &#123;<br>    q.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;Apple&quot;</span>);<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(IllegalStateException e) &#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们调用<code>offer()</code>方法来添加元素，当添加失败时，它不会抛异常，而是返回<code>false</code>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Queue&lt;String&gt; q = ...<br><span class="hljs-keyword">if</span> (q.offer(<span class="hljs-string">&quot;Apple&quot;</span>)) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们需要从<code>Queue</code>中取出队首元素时，如果当前<code>Queue</code>是一个空队列，调用<code>remove()</code>方法，它会抛出异常：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Queue&lt;<span class="hljs-keyword">String</span>&gt; q = ...<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">String</span> s = q.<span class="hljs-built_in">remove</span>();<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;获取成功&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(IllegalStateException e) &#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>==如果我们调用<code>poll()</code>方法来取出队首元素，当获取失败时，它不会抛异常，而是返回<code>null</code>==：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Queue</span>&lt;<span class="hljs-built_in">String</span>&gt; q = <span class="hljs-params">...</span><br><span class="hljs-built_in">String</span> s = q.poll();<br><span class="hljs-keyword">if</span> (s != <span class="hljs-built_in">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取成功&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，两套方法可以根据需要来选择使用。</p><p>注意：不要把<code>null</code>添加到队列中，否则<code>poll()</code>方法返回<code>null</code>时，很难确定是取到了<code>null</code>元素还是队列为空。</p><p>接下来我们以<code>poll()</code>和<code>peek()</code>为例来说说“获取并删除”与“获取但不删除”的区别。对于<code>Queue</code>来说，每次调用<code>poll()</code>，都会获取队首元素，并且获取到的元素已经从队列中被删除了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-comment">// 从队列取出元素:</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// pear</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// banana</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列是空的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果用<code>peek()</code>，因为获取队首元素时，并不会从队列中删除这个元素，所以可以反复获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        <span class="hljs-comment">// 队首永远都是apple，因为peek()不会删除它:</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.peek()); <span class="hljs-comment">// apple</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从上面的代码中，我们还可以发现，<code>LinkedList</code>即实现了<code>List</code>接口，又实现了<code>Queue</code>接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是一个List:</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-comment">// 这是一个Queue:</span><br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br></code></pre></td></tr></table></figure><p>始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</p><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p>队列<code>Queue</code>实现了一个先进先出（FIFO）的数据结构：</p><ul><li>通过<code>add()</code>/<code>offer()</code>方法将元素添加到队尾；</li><li>通过<code>remove()</code>/<code>poll()</code>从队首获取元素并删除；</li><li>通过<code>element()</code>/<code>peek()</code>从队首获取元素但不删除。</li></ul><p>==要避免把<code>null</code>添加到队列==。</p><h4 id="使用PriorityQueue"><a href="#使用PriorityQueue" class="headerlink" title="使用PriorityQueue"></a>使用PriorityQueue</h4><p>我们知道，<code>Queue</code>是一个先进先出（FIFO）的队列。</p><p>在银行柜台办业务时，我们假设只有一个柜台在办理业务，但是办理业务的人很多，怎么办？</p><p>可以每个人先取一个号，例如：<code>A1</code>、<code>A2</code>、<code>A3</code>……然后，按照号码顺序依次办理，实际上这就是一个<code>Queue</code>。</p><p>如果这时来了一个VIP客户，他的号码是<code>V1</code>，虽然当前排队的是<code>A10</code>、<code>A11</code>、<code>A12</code>……但是柜台下一个呼叫的客户号码却是<code>V1</code>。</p><p>这个时候，我们发现，要实现“VIP插队”的业务，用<code>Queue</code>就不行了，因为<code>Queue</code>会严格按FIFO的原则取出队首元素。我们需要的是优先队列：<code>PriorityQueue</code>。</p><p>==<code>PriorityQueue</code>和<code>Queue</code>的区别在于，==</p><ul><li><p>它的出队顺序与元素的优先级有关，</p></li><li><p>对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p></li></ul><p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看<code>PriorityQueue</code>的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;String&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-string">&quot;apple&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;pear&quot;</span>);<br>        q.offer(<span class="hljs-string">&quot;banana&quot;</span>);<br>        System.out.println(q.poll()); <span class="hljs-comment">// apple</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// banana</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// pear</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>们放入的顺序是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;banana&quot;</code>，但是取出的顺序却是<code>&quot;apple&quot;</code>、<code>&quot;banana&quot;</code>、<code>&quot;pear&quot;</code>，这是因为从字符串的排序看，<code>&quot;apple&quot;</code>排在最前面，<code>&quot;pear&quot;</code>排在最后面。</p><p>因此，放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</p><p>如果我们要放入的元素并没有实现<code>Comparable</code>接口怎么办？<code>PriorityQueue</code>允许我们提供一个<code>Comparator</code>对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个<code>PriorityQueue</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Queue&lt;User&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<span class="hljs-keyword">new</span> UserComparator());<br>        <span class="hljs-comment">// 添加3个元素到队列:</span><br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;A1&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;A2&quot;</span>));<br>        q.offer(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Boss&quot;</span>, <span class="hljs-string">&quot;V1&quot;</span>));<br>        System.out.println(q.poll()); <span class="hljs-comment">// Boss/V1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Bob/A1</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// Alice/A2</span><br>        System.out.println(q.poll()); <span class="hljs-comment">// null,因为队列为空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(User u1, User u2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == u2.number.charAt(<span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span><br>            <span class="hljs-keyword">return</span> u1.number.compareTo(u2.number);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;V&#x27;</span>) &#123;<br>            <span class="hljs-comment">// u1的号码是V开头,优先级高:</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String number;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, String number)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;/&quot;</span> + number;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现<code>PriorityQueue</code>的关键在于提供的<code>UserComparator</code>对象，它负责比较两个元素的大小（较小的在前）。<code>UserComparator</code>总是把<code>V</code>开头的号码优先返回，只有在开头相同的时候，才比较号码大小。</p><p>上面的<code>UserComparator</code>的比较逻辑其实还是有问题的，它会把<code>A10</code>排在<code>A2</code>的前面，请尝试修复该错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(User u1, User u2)</span> </span>&#123;<br><span class="hljs-comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span><br><span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == u2.number.charAt(<span class="hljs-number">0</span>)) &#123;<br><span class="hljs-comment">// 相同的字母开头，截取后面的值</span><br><span class="hljs-keyword">int</span> v1 = u1.number.length();<br><span class="hljs-keyword">int</span> v2 = u2.number.length();<br>String n1 = u1.number.substring(<span class="hljs-number">1</span>, v1);<br>String n2 = u2.number.substring(<span class="hljs-number">1</span>, v2);<br><span class="hljs-comment">// 负值，n1排前面</span><br><span class="hljs-keyword">return</span> Integer.parseInt(n1) - Integer.parseInt(n2);<br>&#125;<br><span class="hljs-keyword">if</span> (u1.number.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;V&#x27;</span>) &#123;<br><span class="hljs-comment">// u1的号码是V开头,优先级高:</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双端队列Deque"><a href="#双端队列Deque" class="headerlink" title="双端队列Deque"></a>双端队列Deque</h4><p>我们知道，<code>Queue</code>是队列，只能一头进，另一头出。</p><p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名<code>Deque</code>。</p><p>Java集合提供了接口<code>Deque</code>来实现一个双端队列，它的功能是：</p><ul><li>既可以添加到队尾，也可以添加到队首；</li><li>既可以从队首获取，又可以从队尾获取。</li></ul><p>我们来比较一下<code>Queue</code>和<code>Deque</code>出队和入队的方法：</p><table><thead><tr><th align="left"></th><th align="left">Queue</th><th align="left">Deque</th></tr></thead><tbody><tr><td align="left">添加元素到队尾</td><td align="left">add(E e) / offer(E e)</td><td align="left">addLast(E e) / offerLast(E e)</td></tr><tr><td align="left">取队首元素并删除</td><td align="left">E remove() / E poll()</td><td align="left">E removeFirst() / E pollFirst()</td></tr><tr><td align="left">取队首元素但不删除</td><td align="left">E element() / E peek()</td><td align="left">E getFirst() / E peekFirst()</td></tr><tr><td align="left">添加元素到队首</td><td align="left">无</td><td align="left">addFirst(E e) / offerFirst(E e)</td></tr><tr><td align="left">取队尾元素并删除</td><td align="left">无</td><td align="left">E removeLast() / E pollLast()</td></tr><tr><td align="left">取队尾元素但不删除</td><td align="left">无</td><td align="left">E getLast() / E peekLast()</td></tr></tbody></table><p>对于添加元素到队尾的操作，<code>Queue</code>提供了<code>add()</code>/<code>offer()</code>方法，而<code>Deque</code>提供了<code>addLast()</code>/<code>offerLast()</code>方法。添加元素到对首、取队尾元素的操作在<code>Queue</code>中不存在，在<code>Deque</code>中由<code>addFirst()</code>/<code>removeLast()</code>等方法提供。</p><p>注意到<code>Deque</code>接口实际上扩展自<code>Queue</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，<code>Queue</code>提供的<code>add()</code>/<code>offer()</code>方法在<code>Deque</code>中也可以使用，但是，使用<code>Deque</code>，最好不要调用<code>offer()</code>，而是调用<code>offerLast()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        deque.offerLast(<span class="hljs-string">&quot;A&quot;</span>); <span class="hljs-comment">// A</span><br>        deque.offerLast(<span class="hljs-string">&quot;B&quot;</span>); <span class="hljs-comment">// A &lt;- B</span><br>        deque.offerFirst(<span class="hljs-string">&quot;C&quot;</span>); <span class="hljs-comment">// C &lt;- A &lt;- B</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// C, 剩下A &lt;- B</span><br>        System.out.println(deque.pollLast()); <span class="hljs-comment">// B, 剩下A</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// A</span><br>        System.out.println(deque.pollFirst()); <span class="hljs-comment">// null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接写<code>deque.offer()</code>，我们就需要思考，<code>offer()</code>实际上是<code>offerLast()</code>，我们明确地写上<code>offerLast()</code>，不需要思考就能一眼看出这是添加到队尾。</p><p>因此，使用<code>Deque</code>，推荐总是明确调用<code>offerLast()</code>/<code>offerFirst()</code>或者<code>pollFirst()</code>/<code>pollLast()</code>方法。</p><p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p><p>我们发现<code>LinkedList</code>真是一个全能选手，它即是<code>List</code>，又是<code>Queue</code>，还是<code>Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不推荐的写法:</span><br>LinkedList&lt;String&gt; d1 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>d1.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br><span class="hljs-comment">// 推荐的写法：</span><br>Deque&lt;String&gt; d2 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>d2.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br></code></pre></td></tr></table></figure><p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><p><code>Deque</code>实现了一个双端队列（Double Ended Queue），它可以：</p><ul><li>将元素添加到队尾或队首：<code>addLast()</code>/<code>offerLast()</code>/<code>addFirst()</code>/<code>offerFirst()</code>；</li><li>从队首／队尾获取元素并删除：<code>removeFirst()</code>/<code>pollFirst()</code>/<code>removeLast()</code>/<code>pollLast()</code>；</li><li>从队首／队尾获取元素但不删除：<code>getFirst()</code>/<code>peekFirst()</code>/<code>getLast()</code>/<code>peekLast()</code>；</li><li>总是调用<code>xxxFirst()</code>/<code>xxxLast()</code>以便与<code>Queue</code>的方法区分开；</li><li>避免把<code>null</code>添加到队列。</li></ul><h4 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h4><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p><p>什么是LIFO呢？我们先回顾一下<code>Queue</code>的特点FIFO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ascii">          ────────────────────────<br>  (\(\      (\(\    (\(\    (\(\      (\(\<br> (&#x3D;&#39;.&#39;) ─&gt; (&#x3D;&#39;.&#39;)  (&#x3D;&#39;.&#39;)  (&#x3D;&#39;.&#39;) ─&gt; (&#x3D;&#39;.&#39;)<br>O(_&quot;)&quot;)   O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;)   O(_&quot;)&quot;)<br>          ────────────────────────<br></code></pre></td></tr></table></figure><p>所谓FIFO，是最先进队列的元素一定最早出队列，而LIFO是最后进<code>Stack</code>的元素一定最早出<code>Stack</code>。如何做到这一点呢？只需要把队列的一端封死：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ascii">           ───────────────────────────────┐<br>  (\(\       (\(\    (\(\    (\(\    (\(\ │<br> (&#x3D;&#39;.&#39;) &lt;─&gt; (&#x3D;&#39;.&#39;)  (&#x3D;&#39;.&#39;)  (&#x3D;&#39;.&#39;)  (&#x3D;&#39;.&#39;)│<br>O(_&quot;)&quot;)    O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;)│<br>           ───────────────────────────────┘<br></code></pre></td></tr></table></figure><p>因此，<code>Stack</code>是这样一种数据结构：只能不断地往<code>Stack</code>中压入（push）元素，最后进去的必须最早弹出（pop）来：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1285759053070401/l" alt="donuts-stack"></p><hr><p><code>Stack</code>只有入栈和出栈的操作：</p><ul><li>把元素压栈：<code>push(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop()</code>；</li><li>取栈顶元素但不弹出：<code>peek()</code>。</li></ul><p>在Java中，我们==用<code>Deque</code>==可以实现<code>Stack</code>的功能：</p><ul><li>把元素压栈：<code>push(E)</code>/<code>addFirst(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop()</code>/<code>removeFirst()</code>；</li><li>取栈顶元素但不弹出：<code>peek()</code>/<code>peekFirst()</code>。</li></ul><p>为什么Java的集合类没有单独的<code>Stack</code>接口呢？</p><p>因为有个遗留类名字就叫<code>Stack</code>，出于兼容性考虑，所以没办法创建<code>Stack</code>接口，只能用<code>Deque</code>接口来“模拟”一个<code>Stack</code>了。</p><p>当我们把<code>Deque</code>作为<code>Stack</code>使用时，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，不要调用<code>addFirst()</code>/<code>removeFirst()</code>/<code>peekFirst()</code>方法，这样代码更加清晰。</p><h4 id="Stack的作用"><a href="#Stack的作用" class="headerlink" title="Stack的作用"></a>Stack的作用</h4><p>Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    foo(<span class="hljs-number">123</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">foo</span><span class="hljs-params">(x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;F-&quot;</span> + bar(x + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &lt;&lt; <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。</p><p>因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发<code>StackOverflowError</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        increase(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">increase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> increase(x) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="后缀计算"><a href="#后缀计算" class="headerlink" title="后缀计算"></a>后缀计算</h4><p>利用栈的特性计算</p><p>这个编译过程就会用到栈。我们先跳过编译这一步（涉及运算优先级，代码比较复杂），看看如何通过栈计算后缀表达式。</p><p>计算后缀表达式不考虑优先级，直接从左到右依次计算，因此计算起来简单。首先准备一个空的栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>└───┘<br></code></pre></td></tr></table></figure><p>然后我们依次扫描后缀表达式<code>1 2 9 5 - * +</code>，遇到数字<code>1</code>，就直接扔到栈里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 1 │<br>└───┘<br></code></pre></td></tr></table></figure><p>紧接着，遇到数字<code>2</code>，<code>9</code>，<code>5</code>，也扔到栈里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">│   │<br>│ 5 │<br>│   │<br>│ 9 │<br>│   │<br>│ 2 │<br>│   │<br>│ 1 │<br>└───┘<br></code></pre></td></tr></table></figure><p>接下来遇到减号时，弹出栈顶的两个元素，并计算<code>9-5=4</code>，把结果<code>4</code>压栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">│   │<br>│   │<br>│   │<br>│ 4 │<br>│   │<br>│ 2 │<br>│   │<br>│ 1 │<br>└───┘<br></code></pre></td></tr></table></figure><p>接下来遇到<code>*</code>号时，弹出栈顶的两个元素，并计算<code>2*4=8</code>，把结果<code>8</code>压栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 8 │<br>│   │<br>│ 1 │<br>└───┘<br></code></pre></td></tr></table></figure><p>接下来遇到<code>+</code>号时，弹出栈顶的两个元素，并计算<code>1+8=9</code>，把结果<code>9</code>压栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│   │<br>│ 9 │<br>└───┘<br></code></pre></td></tr></table></figure><p>扫描结束后，没有更多的计算了，弹出栈的唯一一个元素，得到计算结果<code>9</code>。</p><hr><h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><p>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：</p><ul><li>把元素压栈：<code>push(E)</code>；</li><li>把栈顶的元素“弹出”：<code>pop(E)</code>；</li><li>取栈顶元素但不弹出：<code>peek(E)</code>。</li></ul><p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，避免调用<code>Deque</code>的其他方法。</p><p>最后，不要使用遗留类<code>Stack</code>。</p><hr><h4 id="迭代器Iteration"><a href="#迭代器Iteration" class="headerlink" title="迭代器Iteration"></a>迭代器Iteration</h4><p>Java的集合类都可以使用<code>for each</code>循环，<code>List</code>、<code>Set</code>和<code>Queue</code>会迭代每个元素，<code>Map</code>会迭代每个key。以<code>List</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>);<br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，Java编译器并不知道如何遍历<code>List</code>。上述代码能够编译通过，只是因为编译器把<code>for each</code>循环通过<code>Iterator</code>改写为了普通的<code>for</code>循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;<br>     String s = it.next();<br>     System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p><hr><p><strong>使用迭代器的好处在于，</strong></p><p><strong>调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</strong></p><hr><p>例如，我们虽然知道<code>ArrayList</code>在内部是以数组形式存储元素，并且，它还提供了<code>get(int)</code>方法。虽然我们可以用<code>for</code>循环遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>    Object value = list.get(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把<code>ArrayList</code>换成<code>LinkedList</code>，<code>get(int)</code>方法耗时会随着index的增加而增加。如果把<code>ArrayList</code>换成<code>Set</code>，上述代码就无法编译，因为<code>Set</code>内部没有索引。</p><p>用<code>Iterator</code>遍历就没有上述问题，因为<code>Iterator</code>对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的<code>for each</code>循环自动转换为<code>Iterator</code>遍历。</p><p>如果我们自己编写了一个集合类，想要使用<code>for each</code>循环，只需满足以下条件：</p><ul><li>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</li><li>用<code>Iterator</code>对象迭代集合内部数据。</li></ul><p>这里的关键在于，集合类通过调用<code>iterator()</code>方法，返回一个<code>Iterator</code>对象，这个对象必须自己知道如何遍历该集合。</p><p>一个简单的<code>Iterator</code>示例如下，它总是以倒序遍历集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReverseList&lt;String&gt; rlist = <span class="hljs-keyword">new</span> ReverseList&lt;&gt;();<br>        rlist.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        rlist.add(<span class="hljs-string">&quot;Orange&quot;</span>);<br>        rlist.add(<span class="hljs-string">&quot;Pear&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : rlist) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T t)</span> </span>&#123;<br>        list.add(t);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReverseIterator(list.size());<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> index;<br><br>        ReverseIterator(<span class="hljs-keyword">int</span> index) &#123;<br>            <span class="hljs-keyword">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> index &gt; <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            index--;<br>            <span class="hljs-keyword">return</span> ReverseList.<span class="hljs-keyword">this</span>.list.get(index);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>虽然<code>ReverseList</code>和<code>ReverseIterator</code>的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按<code>for each</code>循环编写代码，==根本不需要知道集合内部的存储逻辑和遍历逻辑==。</p><p>在编写<code>Iterator</code>的时候，我们通常可以用==一个内部类来实现<code>Iterator</code>接口==，==这个内部类可以直接访问对应的外部类的所有字段和方法==。例如，上述代码中，内部类<code>ReverseIterator</code>可以用<code>ReverseList.this</code>获得当前外部类的<code>this</code>引用，然后，通过这个<code>this</code>引用就可以访问<code>ReverseList</code>的所有字段和方法。</p><h4 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h4><p><code>Iterator</code>是一种抽象的数据访问模型。使用<code>Iterator</code>模式进行迭代的好处有：</p><ul><li>对任何集合都采用同一种访问模型；</li><li>调用者对集合内部结构一无所知；</li><li>集合类返回的<code>Iterator</code>对象知道如何迭代。</li></ul><p>Java提供了标准的迭代器模型，即集合类实现<code>java.util.Iterable</code>接口，返回<code>java.util.Iterator</code>实例</p><hr><h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><p>Java中Collection和Collections的区别<br>1、java.util.Collection 是一个 集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p><p>2、java.util.Collections 是一个包装类。它包含有各种有关集合操作的 <strong>静态多态方法</strong>。此类 <strong>不能实例化</strong>，就像一 <strong>个工具类</strong>，服务于Java的Collection框架。</p><hr><p><code>Collections</code>是JDK提供的工具类，同样位于<code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p><p> 注意Collections结尾多了一个s，不是Collection！</p><p>我们一般看方法名和参数就可以确认<code>Collections</code>提供的该方法的功能。例如，对于以下静态方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">addAll</span>(<span class="hljs-params">Collection&lt;? <span class="hljs-built_in">super</span> T&gt; c, T... elements</span>)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p><code>addAll()</code>方法可以给一个<code>Collection</code>类型的集合添加若干元素。因为方法签名是<code>Collection</code>，所以我们可以传入<code>List</code>，<code>Set</code>等各种集合类型。</p><h4 id="创建空集合"><a href="#创建空集合" class="headerlink" title="创建空集合"></a>创建空集合</h4><p><code>Collections</code>提供了一系列方法来创建空集合：</p><ul><li>创建空List：<code>List&lt;T&gt; emptyList()</code></li><li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li><li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li></ul><p>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p><p>此外，也可以用各个集合接口提供的<code>of(T...)</code>方法创建空集合。例如，以下创建空<code>List</code>的两个方法是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list1 = List.of();<br>List&lt;String&gt; list2 = Collections.emptyList();<br></code></pre></td></tr></table></figure><hr><h4 id="创建单元素集合"><a href="#创建单元素集合" class="headerlink" title="创建单元素集合"></a>创建单元素集合</h4><p><code>Collections</code>提供了一系列方法来创建一个单元素集合：</p><ul><li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li><li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li><li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li></ul><p>要注意到返回的单元素集合也是==不可变集合，无法向其中添加或删除元素==。</p><p>此外，也可以用各个集合接口提供的<code>of(T...)</code>方法创建单元素集合。例如，以下创建单元素<code>List</code>的两个方法是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list1 = List.of(<span class="hljs-string">&quot;apple&quot;</span>);<br>List&lt;String&gt; list2 = Collections.singletonList(<span class="hljs-string">&quot;apple&quot;</span>);<br></code></pre></td></tr></table></figure><p>实际上，==使用<code>List.of(T...)</code>更方便==，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list1 = List.of(); <span class="hljs-comment">// empty list</span><br>List&lt;String&gt; list2 = List.of(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// 1 element</span><br>List&lt;String&gt; list3 = List.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>); <span class="hljs-comment">// 2 elements</span><br>List&lt;String&gt; list4 = List.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>); <span class="hljs-comment">// 3 elements</span><br></code></pre></td></tr></table></figure><hr><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p><code>Collections</code>可以对<code>List</code>进行排序。因为排序会直接修改<code>List</code>元素的位置，因此必须传入可变<code>List</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;pear&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;orange&quot;</span>);<br>        <span class="hljs-comment">// 排序前:</span><br>        System.out.println(list);<br>        Collections.sort(list);<br>        <span class="hljs-comment">// 排序后:</span><br>        System.out.println(list);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h4 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a>洗牌</h4><p><code>Collections</code>提供了洗牌算法，即传入一个有序的<code>List</code>，可以随机打乱<code>List</code>内部元素的顺序，效果相当于让计算机洗牌：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>            list.add(i);<br>        &#125;<br>        <span class="hljs-comment">// 洗牌前:</span><br>        System.out.println(list);<br>        Collections.shuffle(list);<br>        <span class="hljs-comment">// 洗牌后:</span><br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h4><p><code>Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p><ul><li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li><li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li><li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li></ul><p>这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的。我们来看看效果：</p><p>然而，继续对原始的可变<code>List</code>进行增删是可以的，并且，会直接影响到封装后的“不可变”<code>List</code>：</p><p>因此，如果我们希望把一个可变<code>List</code>封装成不可变<code>List</code>，那么，返回不可变<code>List</code>后，最好立刻扔掉可变<code>List</code>的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”<code>List</code>变化了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; mutable = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        mutable.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        mutable.add(<span class="hljs-string">&quot;pear&quot;</span>);<br>        <span class="hljs-comment">// 变为不可变集合:</span><br>        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);<br>        mutable.add(<span class="hljs-string">&quot;orange&quot;</span>);<br>        <span class="hljs-comment">// 立刻扔掉mutable的引用:</span><br>        mutable = <span class="hljs-keyword">null</span>;<br>        System.out.println(immutable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h4><p><code>Collections</code>还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p><ul><li>变为线程安全的List：<code>List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li><li>变为线程安全的Set：<code>Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li><li>变为线程安全的Map：<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li></ul><p>多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p><h4 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h4><p><code>Collections</code>类提供了一组工具方法来方便使用集合类：</p><ul><li>创建空集合；</li><li>创建单元素集合；</li><li>创建不可变集合；</li><li>排序／洗牌等操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>集合</category>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3无重复字符的最长子串</title>
    <link href="/2021/10/08/3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/10/08/3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">示例 1:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-comment">输出: 3</span><br><span class="hljs-comment">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="hljs-comment">* */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_3</span>无重复字符的最长子串 </span>&#123;<br>    <span class="hljs-comment">//滑动窗口技巧</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">//哈希集合，记录每字符是否出现过</span><br>        Set&lt;Character&gt; occ = <span class="hljs-keyword">new</span> HashSet&lt;Character&gt;();<br><br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-comment">//右指针，初始值为-1，相当于我们在字符串的左边界的左侧，还没有开始移动、</span><br>        <span class="hljs-keyword">int</span> rk = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//记录最长子串的长度</span><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//除了第一次循环添加，之后的每一次循环，左指针都要向右边移动一次，知道字符串结束</span><br>                occ.remove(s.charAt(i - <span class="hljs-number">1</span>));<br>            &#125;<br>            <span class="hljs-comment">//用while（条件）循环，添加不重复的字符串，直到字符串结束</span><br>            <span class="hljs-keyword">while</span> (rk + <span class="hljs-number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class="hljs-number">1</span>))) &#123;<br>                <span class="hljs-comment">//右指针不断右移</span><br>                occ.add(s.charAt(rk + <span class="hljs-number">1</span>));<br>                rk++;<br>            &#125;<br>            <span class="hljs-comment">//这里得到的子串都是不重复子串</span><br>            <span class="hljs-comment">//获取字符串最长的长度</span><br>            res = Math.max(res, rk + <span class="hljs-number">1</span> - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = lengthOfLongestSubstring(<span class="hljs-string">&quot;pwwkew&quot;</span>);<br>        System.out.println(x);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>滑动窗口技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2021/10/07/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2021/10/07/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="1-什么是泛型"><a href="#1-什么是泛型" class="headerlink" title="1.什么是泛型"></a>1.什么是泛型</h4><p>泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为类创建对象的<code>ArrayList&lt;类型&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; strList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br></code></pre></td></tr></table></figure><p>由编译器针对类型作检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">strList.add(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// OK</span><br>String s = strList.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// OK</span><br>strList.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>)); <span class="hljs-comment">// compile error!</span><br>Integer n = strList.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p><p><strong>为什么会有泛型呢</strong></p><blockquote><p>我们先观察Java标准库提供的<code>ArrayList</code>，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p><p>实际上<code>ArrayList</code>内部就是一个<code>Object[]</code>数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span> </span>&#123;<br> <span class="hljs-keyword">private</span> Object[] array;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object e)</span> </span>&#123;...&#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果用上述<code>ArrayList</code>存储<code>String</code>类型，会有这么几个缺点：</p><ul><li>需要强制转型；</li><li>不方便，易出错。</li></ul><p>例如，代码必须这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-comment">// 获取到Object，必须强制转型为String:</span><br>String first = (String) list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>很容易出现ClassCastException，因为容易“误转型”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">list.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>));<br><span class="hljs-comment">// ERROR: ClassCastException:</span><br>String second = (String) list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>要解决上述问题，我们可以为<code>String</code>单独编写一种<code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringArrayList</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，存入的必须是<code>String</code>，取出的也一定是<code>String</code>，不需要强制转型，因为编译器会强制检查放入的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">StringArrayList list = <span class="hljs-keyword">new</span> StringArrayList();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>String first = list.get(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 编译错误: 不允许放入非String类型:</span><br>list.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>));<br></code></pre></td></tr></table></figure><p>问题暂时解决。</p><p>然而，新的问题是，如果要存储<code>Integer</code>，还需要为<code>Integer</code>单独编写一种<code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerArrayList</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer e)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，还需要为其他所有class单独编写一种<code>ArrayList</code>：</p><ul><li>LongArrayList</li><li>DoubleArrayList</li><li>PersonArrayList</li><li>…</li></ul><p>这是不可能的，JDK的class就有上千个，而且它还不知道其他人编写的class。</p><p>为了解决新的问题，我们必须把<code>ArrayList</code>变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T e)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>T</code>可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的<code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建可以存储String的ArrayList:</span><br>ArrayList&lt;String&gt; strList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><span class="hljs-comment">// 创建可以存储Float的ArrayList:</span><br>ArrayList&lt;Float&gt; floatList = <span class="hljs-keyword">new</span> ArrayList&lt;Float&gt;();<br><span class="hljs-comment">// 创建可以存储Person的ArrayList:</span><br>ArrayList&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;Person&gt;();<br></code></pre></td></tr></table></figure></blockquote><h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><p>在Java标准库中的<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，它可以向上转型为<code>List&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    ...<br>&#125;<br><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br></code></pre></td></tr></table></figure><p>即类型<code>ArrayList&lt;T&gt;</code>可以向上转型为<code>List&lt;T&gt;</code>。</p><p>要<em>特别注意</em>：不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code>。</p><p>这是为什么呢？假设<code>ArrayList&lt;Integer&gt;</code>可以向上转型为<code>ArrayList&lt;Number&gt;</code>，观察一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建ArrayList&lt;Integer&gt;类型：</span><br>ArrayList&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><span class="hljs-comment">// 添加一个Integer：</span><br>integerList.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>));<br><span class="hljs-comment">// “向上转型”为ArrayList&lt;Number&gt;：</span><br>ArrayList&lt;Number&gt; numberList = integerList;<br><span class="hljs-comment">// 添加一个Float，因为Float也是Number：</span><br>numberList.add(<span class="hljs-keyword">new</span> Float(<span class="hljs-number">12.34</span>));<br><span class="hljs-comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span><br>Integer n = integerList.get(<span class="hljs-number">1</span>); <span class="hljs-comment">// ClassCastException!</span><br></code></pre></td></tr></table></figure><p>我们把一个<code>ArrayList&lt;Integer&gt;</code>转型为<code>ArrayList&lt;Number&gt;</code>类型后，这个<code>ArrayList&lt;Number&gt;</code>就可以接受<code>Float</code>类型，因为<code>Float</code>是<code>Number</code>的子类。但是，<code>ArrayList&lt;Number&gt;</code>实际上和<code>ArrayList&lt;Integer&gt;</code>是同一个对象，也就是<code>ArrayList&lt;Integer&gt;</code>类型，它不可能接受<code>Float</code>类型， 所以在获取<code>Integer</code>的时候将产生<code>ClassCastException</code>。</p><p>==实际上，编译器为了避免这种错误，根本就不允许把<code>ArrayList&lt;Integer&gt;</code>转型为<code>ArrayList&lt;Number&gt;</code>。==</p><p>==ArrayList<Integer>和ArrayList<Number>两者完全没有继承关系。==</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>泛型就是编写模板代码来使用任意类型；</li><li>泛型的好处是使用时不必对类型进行强制转换，他通过编译器对类型的检查；</li><li>注意泛型的继承关系：可以把 <code>ArrayList&lt;Integer&gt;</code>向上转型为<code>List&lt;Integer&gt;</code>(==T 即数据类型不能变==)，但不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>（<code>T</code>不能变成父类）。</li></ul><hr><h4 id="2-使用泛型"><a href="#2-使用泛型" class="headerlink" title="2.使用泛型"></a>2.使用泛型</h4><p>使用<code>ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是<code>Object</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编译器警告:</span><br>List list = <span class="hljs-keyword">new</span> ArrayList();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>list.add(<span class="hljs-string">&quot;World&quot;</span>);<br>String first = (String) list.get(<span class="hljs-number">0</span>);<br>String second = (String) list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>此时，只能把<code>&lt;T&gt;</code>当作<code>Object</code>使用，没有发挥泛型的优势。</p><p>当我们定义泛型类型<code>&lt;String&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;String&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无编译器警告:</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>list.add(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// 无强制转型:</span><br>String first = list.get(<span class="hljs-number">0</span>);<br>String second = list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>当我们定义泛型类型<code>&lt;Number&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>list.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>));<br>list.add(<span class="hljs-keyword">new</span> Double(<span class="hljs-number">12.34</span>));<br>Number first = list.get(<span class="hljs-number">0</span>);<br>Number second = list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br></code></pre></td></tr></table></figure><p>编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span><br>List&lt;Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br></code></pre></td></tr></table></figure><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><p>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Comparable</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回负数: 当前实例比参数o小</span><br><span class="hljs-comment">     * 返回0: 当前实例与参数o相等</span><br><span class="hljs-comment">     * 返回正数: 当前实例比参数o大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">int</span> compareTo(T o);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以直接对<code>String</code>数组进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sort</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为<code>String</code>本身已经实现了<code>Comparable&lt;String&gt;</code>接口。如果换成我们自定义的<code>Person</code>类型试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sort</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>         Person[] ps = <span class="hljs-keyword">new</span> Person[] &#123;<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">61</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">75</span>),<br>        &#125;;<br>        Arrays.sort(ps);<br>        System.out.println(Arrays.toString(ps));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序，我们会得到<code>ClassCastException</code>，即无法将<code>Person</code>转型为<code>Comparable</code>。我们修改代码，让<code>Person</code>实现<code>Comparable&lt;T&gt;</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sort</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>         Person[] ps = <span class="hljs-keyword">new</span> Person[] &#123;<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">61</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Lily&quot;</span>, <span class="hljs-number">75</span>),<br>        &#125;;<br>        Arrays.sort(ps);<br>        System.out.println(Arrays.toString(ps));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> Person implements Comparable&lt;Person&gt;&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> score;<br>    Person(String name, <span class="hljs-keyword">int</span> score)&#123;<br><span class="hljs-keyword">this</span>.name =name;<br>        <span class="hljs-keyword">this</span>.score = score;<br>       <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Person other)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.compareTo(other.name)<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-keyword">this</span>.score;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>运行上述代码，可以正确实现按<code>name</code>进行排序。</p><p>也可以修改比较逻辑，例如，按<code>score</code>从高到低排序。请自行修改测试。</p><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><ul><li>使用泛型时，把泛型参数<code>&lt;T&gt;</code>替换成需要的class类型，例如：<code>ArrayList&lt;String&gt;</code>,<code>ArrayList&lt;Number&gt;</code>等；</li><li>可以省略编译器能自动推断出的类型，例如：<code>List&lt;String&gt; list = new ArrayList&lt;&gt;()</code>;</li><li>不指定泛型参数类型时，编译器会给出警告，且只能将<code>&lt;T&gt;</code>视为<code>object</code>类型；</li><li>可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</li></ul><hr><h4 id="3-编写泛型"><a href="#3-编写泛型" class="headerlink" title="3.编写泛型"></a>3.编写泛型</h4><p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如<code>ArrayList&lt;T&gt;</code>，我们很少需要编写泛型类。</p><p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p><p>可以按照以下步骤来编写一个泛型类。</p><p>首先，按照某种类型，例如：<code>String</code>，来编写类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String first;<br>    <span class="hljs-keyword">private</span> String last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(String first, String last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，标记所有的特定类型，这里是<code>String</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String first;<br>    <span class="hljs-keyword">private</span> String last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(String first, String last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，把特定类型<code>String</code>替换为<code>T</code>，并申明<code>&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>熟练后即可直接从<code>T</code>开始编写。</p><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>编写泛型类时，要特别注意，泛型类型<code>&lt;T&gt;</code>不能用于静态方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>    <span class="hljs-comment">// 对静态方法使用&lt;T&gt;:</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pair&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;T&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码会导致编译错误，我们无法在静态方法<code>create()</code>的方法参数和返回类型上使用泛型类型<code>T</code>。</p><p>有些同学在网上搜索发现，可以在<code>static</code>修饰符后面加一个<code>&lt;T&gt;</code>，编译就能通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>    <span class="hljs-comment">// 可以编译通过:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Pair&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;T&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但实际上，这个<code>&lt;T&gt;</code>和<code>Pair&lt;T&gt;</code>类型的<code>&lt;T&gt;</code>已经没有任何关系了。</p><p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的<code>create()</code>静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>    <span class="hljs-comment">// 静态泛型方法应该使用其他类型区分:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; <span class="hljs-function">Pair&lt;K&gt; <span class="hljs-title">create</span><span class="hljs-params">(K first, K last)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;K&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</p><h5 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h5><p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> K last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, K last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候，需要指出两种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String, Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>==Java标准库的<code>Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。==</p><h5 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h5><ul><li>编写泛型时，要定义泛型类型==<T>==;</li><li>静态方法不能引用泛型类型==<T>==，必须定义其他类型（例如==<K>==）;</li><li>泛型可以同时定义多种类型，例如==Map&lt;k,V&gt;==</li></ul><hr><h4 id="4-擦拭法"><a href="#4-擦拭法" class="headerlink" title="4.擦拭法"></a>4.擦拭法</h4><p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p><p>==Java语言的泛型实现方式是擦拭法（Type Erasure）。==</p><p>所谓==擦拭法==是指，==虚拟机对泛型其实一无所知，所有的工作都是编译器做的==。</p><p>例如，我们编写了一个泛型类<code>Pair&lt;T&gt;</code>，这是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object first;<br>    <span class="hljs-keyword">private</span> Object last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(Object first, Object last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，Java使用擦拭法实现泛型，导致了：</p><ul><li><strong>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</strong></li><li><strong>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</strong></li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>String first = p.getFirst();<br>String last = p.getLast();<br></code></pre></td></tr></table></figure><p>而虚拟机执行的代码并没有泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair p = <span class="hljs-keyword">new</span> Pair(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>String first = (String) p.getFirst();<br>String last = (String) p.getLast();<br></code></pre></td></tr></table></figure><p>所以，java的泛型时由编译器在编译时实行的，编译器内部永远把所有的<code>&lt;T&gt;</code>当做<code>object</code>处理，但是在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p><p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的<strong>局限：</strong></p><p>==局限一==：<code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;<span class="hljs-keyword">int</span>&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>==局限二==：无法取得带泛型的<code>Class</code>。观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pair&lt;String&gt; p1 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>        Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        Class c1 = p1.getClass();<br>        Class c2 = p2.getClass();<br>        System.out.println(c1==c2); <span class="hljs-comment">// true</span><br>        System.out.println(c1==Pair.class); <span class="hljs-comment">// true</span><br>           &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>T</code>是<code>Object</code>，我们对<code>Pair&lt;String&gt;</code>和<code>Pair&lt;Integer&gt;</code>类型获取<code>Class</code>时，获取到的是同一个<code>Class</code>，也就是<code>Pair</code>类的<code>Class</code>。</p><p>换句话说，所有泛型实例，无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例，因为编译后它们全部都是<code>Pair&lt;Object&gt;</code>。</p><p>局限三：无法判断带泛型的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br><span class="hljs-comment">// Compile error:</span><br><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Pair&lt;String&gt;) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因和前面一样，并不存在<code>Pair&lt;String&gt;.class</code>，而是只有唯一的<code>Pair.class</code>。</p><p>局限四：不能实例化<code>T</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Compile error:</span><br>        first = <span class="hljs-keyword">new</span> T();<br>        last = <span class="hljs-keyword">new</span> T();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码无法通过编译，因为构造方法的两行语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">first = <span class="hljs-keyword">new</span> T();<br>last = <span class="hljs-keyword">new</span> T();<br></code></pre></td></tr></table></figure><p>擦拭后实际上变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">first = <span class="hljs-keyword">new</span> Object();<br>last = <span class="hljs-keyword">new</span> Object();<br></code></pre></td></tr></table></figure><p>这样一来，创建<code>new Pair&lt;String&gt;()</code>和创建<code>new Pair&lt;Integer&gt;()</code>就全部成了<code>Object</code>，显然编译器要阻止这种类型不对的代码。</p><p><strong>要实例化<code>T</code>类型，我们必须借助额外的<code>Class&lt;T&gt;</code>参数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>        first = clazz.newInstance();<br>        last = clazz.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码借助<code>Class&lt;T&gt;</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class&lt;T&gt;</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt; pair = <span class="hljs-keyword">new</span> Pair&lt;&gt;(String.class);<br></code></pre></td></tr></table></figure><p>因为传入了<code>Class&lt;String&gt;</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p><h5 id="不恰当的覆写方法"><a href="#不恰当的覆写方法" class="headerlink" title="不恰当的覆写方法"></a>不恰当的覆写方法</h5><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Pair</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean equals(T t) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为，定义的<code>equals(T t)</code>方法实际上会被擦拭成<code>equals(Object t)</code>，而这个方法是继承自<code>Object</code>的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>换个方法名，避开与<code>Object.equals(Object)</code>的冲突就可以成功编译：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Pair</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean same(T t) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h5><p>一个类可以继承自一个泛型类。例如：父类的类型是<code>Pair&lt;Integer&gt;</code>，子类的类型是<code>IntPair</code>，可以这么继承：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntPair</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pair&lt;Integer&gt;</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候，因为子类<code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">IntPair</span> ip = new IntPair(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>前面讲了，我们无法获取<code>Pair&lt;T&gt;</code>的<code>T</code>类型，即给定一个变量<code>Pair&lt;Integer&gt; p</code>，无法从<code>p</code>中获取到<code>Integer</code>类型。</p><p>但是，在父类是泛型类型的情况下，编译器就必须把类型<code>T</code>（对<code>IntPair</code>来说，也就是<code>Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code>IntPair</code>只能存取<code>Integer</code>这种类型。</p><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：<code>IntPair</code>可以获取到父类的泛型类型<code>Integer</code>。获取父类的泛型类型代码比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<br><span class="hljs-keyword">import</span> java.lang.reflect.Type;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class&lt;IntPair&gt; clazz = IntPair.class;<br>        Type t = clazz.getGenericSuperclass();<br>        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            ParameterizedType pt = (ParameterizedType) t;<br>            Type[] types = pt.getActualTypeArguments(); <span class="hljs-comment">// 可能有多个泛型类型</span><br>            Type firstType = types[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 取第一个泛型类型</span><br>            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;<br>            System.out.println(typeClass); <span class="hljs-comment">// Integer</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntPair</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IntPair</span><span class="hljs-params">(Integer first, Integer last)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为Java引入了泛型，所以，只用<code>Class</code>来标识类型已经不够了。实际上，Java的类型系统结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                      ┌────┐<br>                      │Type│<br>                      └────┘<br>                         ▲<br>                         │<br>   ┌────────────┬────────┴─────────┬───────────────┐<br>   │            │                  │               │<br>┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐<br>│Class││ParameterizedType││GenericArrayType││WildcardType│<br>└─────┘└─────────────────┘└────────────────┘└────────────┘<br></code></pre></td></tr></table></figure><h5 id="小结：-2"><a href="#小结：-2" class="headerlink" title="小结："></a>小结：</h5><ul><li><p>java泛型是采用擦拭法实现的</p></li><li><p>擦拭法决定了泛型<code>T</code>:</p><ul><li>不能是八大基本类型，比如 int </li><li>不能获得带泛型类型的<code>class</code>，例如：Pair<String>.class;</li><li>不能判断带泛型类型的类型，比如：<code>x instanceof Pair&lt;String&gt;.class</code></li><li>不能实例化<code>T</code>类型，例如 <code>new T()</code>.</li></ul></li><li><p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</p></li><li><p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。</p></li></ul><h4 id="5-extends通配符"><a href="#5-extends通配符" class="headerlink" title="5.extends通配符"></a>5.extends通配符</h4><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类。</p><p>假设我们定义了<code>Pair&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>然后，我们又针对<code>Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code>Pair&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PairHelper</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Pair&lt;Number&gt; p)</span> </span>&#123;<br>        Number first = p.getFirst();<br>        Number last = p.getLast();<br>        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码是可以正常编译的。使用的时候，我们传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum = PairHelper.add(<span class="hljs-keyword">new</span> Pair&lt;Number&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>注意：传入的类型是<code>Pair&lt;Number&gt;</code>，实际参数类型是<code>(Integer, Integer)</code>。</p><p>既然实际参数是<code>Integer</code>类型，试试传入<code>Pair&lt;Integer&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        <span class="hljs-keyword">int</span> n = add(p);<br>        System.out.println(n);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Pair&lt;Number&gt; p)</span> </span>&#123;<br>        Number first = p.getFirst();<br>        Number last = p.getLast();<br>        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接运行，会得到一个编译错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">incompatible types: Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;<br></code></pre></td></tr></table></figure><p>原因很明显，因为<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类，因此，<code>add(Pair&lt;Number&gt;)</code>不接受参数类型<code>Pair&lt;Integer&gt;</code>。</p><p>但是从<code>add()</code>方法的代码可知，传入<code>Pair&lt;Integer&gt;</code>是完全符合内部代码的类型规范，因为语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Number first = p.getFirst();<br>Number last = p.getLast();<br></code></pre></td></tr></table></figure><p>实际类型是<code>Integer</code>，引用类型是<code>Number</code>，没有问题。问题在于方法参数类型定死了只能传入<code>Pair&lt;Number&gt;</code>。</p><p>有没有办法使得方法参数接受<code>Pair&lt;Integer&gt;</code>？==办法是有的，这就是使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型==。我们把代码改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        <span class="hljs-keyword">int</span> n = add(p);<br>        System.out.println(n);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;<br>        Number first = p.getFirst();<br>        Number last = p.getLast();<br>        <span class="hljs-keyword">return</span> first.intValue() + last.intValue();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，给方法传入<code>Pair&lt;Integer&gt;</code>类型时，它符合参数<code>Pair&lt;? extends Number&gt;</code>类型。这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为==上界通配符==（Upper Bounds Wildcards），即把泛型类型<code>T</code>的上界限定在<code>Number</code>了</p><p>除了可以传入<code>Pair&lt;Integer&gt;</code>类型，我们还可以传入<code>Pair&lt;Double&gt;</code>类型，<code>Pair&lt;BigDecimal&gt;</code>类型等等，因为<code>Double</code>和<code>BigDecimal</code>都是<code>Number</code>的子类。</p><p>如果我们考察对<code>Pair&lt;? extends Number&gt;</code>类型调用<code>getFirst()</code>方法，实际的方法签名变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;? extends Number&gt; getFirst();<br></code></pre></td></tr></table></figure><p>即返回值是<code>Number</code>或<code>Number</code>的子类，因此，可以安全赋值给<code>Number</code>类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Number x = p.getFirst();<br></code></pre></td></tr></table></figure><p>然后，我们不可预测实际类型就是<code>Integer</code>，例如，下面的代码是无法通过编译的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = p.getFirst();<br></code></pre></td></tr></table></figure><p>这是因为实际的返回类型可能是<code>Integer</code>，也可能是<code>Double</code>或者其他类型，编译器只能确定类型一定是<code>Number</code>的子类（包括<code>Number</code>类型本身），但具体类型无法确定。</p><p>我们再来考察一下<code>Pair&lt;T&gt;</code>的<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        <span class="hljs-keyword">int</span> n = add(p);<br>        System.out.println(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;<br>        Number first = p.getFirst();<br>        Number last = p.getLast();<br>        p.setFirst(<span class="hljs-keyword">new</span> Integer(first.intValue() + <span class="hljs-number">100</span>));<br>        p.setLast(<span class="hljs-keyword">new</span> Integer(last.intValue() + <span class="hljs-number">100</span>));<br>        <span class="hljs-keyword">return</span> p.getFirst().intValue() + p.getFirst().intValue();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(T first)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLast</span><span class="hljs-params">(T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不出意外，我们会得到一个编译错误：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">incompatible types: Integer cannot be converted to CAP#1<br>where CAP#1 is a fresh type-variable:<br>    CAP#1 extends Number from capture of ? extends Number<br></code></pre></td></tr></table></figure><p>编译错误发生在<code>p.setFirst()</code>传入的参数是<code>Integer</code>类型。有些童鞋会问了，既然<code>p</code>的定义是<code>Pair&lt;? extends Number&gt;</code>，那么<code>setFirst(? extends Number)</code>为什么不能传入<code>Integer</code>？</p><p>原因还在于<strong>擦拭法</strong>。如果我们传入的<code>p</code>是<code>Pair&lt;Double&gt;</code>，显然它满足参数定义<code>Pair&lt;? extends Number&gt;</code>，然而，<code>Pair&lt;Double&gt;</code>的<code>setFirst()</code>显然无法接受<code>Integer</code>类型。</p><p>==这就是<code>&lt;? extends Number&gt;</code>通配符的一个重要限制：方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>的子类型给<code>setFirst(? extends Number)</code>。==</p><p>这里唯一的例外是可以给方法参数传入**<code>null</code>**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">p.setFirst(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// ok, 但是后面会抛出NullPointerException</span><br>p.getFirst().intValue(); <span class="hljs-comment">// NullPointerException</span><br></code></pre></td></tr></table></figure><hr><h5 id="extends通配符的作用"><a href="#extends通配符的作用" class="headerlink" title="extends通配符的作用"></a>extends通配符的作用</h5><ul><li>只读不写，限制作用</li></ul><p>如果我们考察Java标准库的<code>java.util.List&lt;T&gt;</code>接口，它实现的是一个类似“可变数组”的列表，主要功能包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 获取个数</span><br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>; <span class="hljs-comment">// 根据索引获取指定元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T t)</span></span>; <span class="hljs-comment">// 添加一个新元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T t)</span></span>; <span class="hljs-comment">// 删除一个已有元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，让我们定义一个方法来处理列表的每个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumOfList</span><span class="hljs-params">(List&lt;? extends Integer&gt; list)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>        Integer n = list.get(i);<br>        sum = sum + n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>为什么我们定义的方法参数类型是<code>List&lt;? extends Integer&gt;</code>而不是<code>List&lt;Integer&gt;</code>？从方法内部代码看，传入<code>List&lt;? extends Integer&gt;</code>或者<code>List&lt;Integer&gt;</code>是完全一样的，但是，注意到<code>List&lt;? extends Integer&gt;</code>的限制：</p><ul><li><strong>允许调用<code>get()</code>方法获取<code>Integer</code>的引用</strong>；</li><li><strong>不允许调用<code>set(? extends Integer)</code>方法并传入任何<code>Integer</code>的引用（<code>null</code>除外）。</strong></li></ul><p><strong>因此，方法参数类型<code>List&lt;? extends Integer&gt;</code>表明了该方法内部只会读取<code>List</code>的元素，不会修改<code>List</code>的元素（因为无法调用<code>add(? extends Integer)</code>、<code>remove(? extends Integer)</code>这些方法。换句话说，这是一个对参数<code>List&lt;? extends Integer&gt;</code>进行==只读==的方法（恶意调用<code>set(null)</code>除外）。</strong></p><hr><h5 id="使用extends限定T类型"><a href="#使用extends限定T类型" class="headerlink" title="使用extends限定T类型"></a>使用extends限定T类型</h5><p>在定义泛型类型<code>Pair&lt;T&gt;</code>的时候，也可以使用<code>extends</code>通配符来限定<code>T</code>的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt; </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>现在，我们只能定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Number&gt; p1 = <span class="hljs-keyword">null</span>;<br>Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Pair&lt;Double&gt; p3 = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>因为<code>Number</code>、<code>Integer</code>和<code>Double</code>都符合<code>&lt;T extends Number&gt;</code>。</p><p>非<code>Number</code>类型将无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt; p1 = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// compile error!</span><br>Pair&lt;Object&gt; p2 = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>因为<code>String</code>、<code>Object</code>都不符合<code>&lt;T extends Number&gt;</code>，因为它们不是<code>Number</code>类型或<code>Number</code>的子类。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><ul><li>使用类似<code>&lt;? extends Number&gt;</code>通配符作为==方法参数==时表示：<ul><li>方法内部可以调用获取Number引用的方法，比如：<code>number n = obj.getFirst()</code>;</li><li>方法内部不可以调用传入<code>number</code>引用的方法（==null除外==），比如：<code>obj.setFirst(Number n)</code>.</li></ul></li><li>**即一句话总结：使用<code>extends</code>通配符表示==可以读，不能写==**。</li><li>使用类似<code>&lt;T extends Number&gt;</code>==定义泛型类==时表示：<ul><li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li></ul></li></ul><h4 id="6-super通配符"><a href="#6-super通配符" class="headerlink" title="6.super通配符"></a>6.super通配符</h4><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类。</p><p>考察下面的<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Pair&lt;Integer&gt; p, Integer first, Integer last)</span> </span>&#123;<br>    p.setFirst(first);<br>    p.setLast(last);<br>&#125;<br></code></pre></td></tr></table></figure><p>传入<code>Pair&lt;Integer&gt;</code>是允许的，但是传入<code>Pair&lt;Number&gt;</code>是不允许的。</p><p>和<code>extends</code>通配符相反，这次，我们希望接受<code>Pair&lt;Integer&gt;</code>类型，以及<code>Pair&lt;Number&gt;</code>、<code>Pair&lt;Object&gt;</code>，因为<code>Number</code>和<code>Object</code>是<code>Integer</code>的父类，<code>setFirst(Number)</code>和<code>setFirst(Object)</code>实际上允许接受<code>Integer</code>类型。</p><p>我们使用<code>super</code>通配符来改写这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Pair&lt;? <span class="hljs-keyword">super</span> Integer&gt; p, Integer first, Integer last)</span> </span>&#123;<br>    p.setFirst(first);<br>    p.setLast(last);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到<code>Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型。</p><p>下面的代码可以被正常编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pair&lt;Number&gt; p1 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">12.3</span>, <span class="hljs-number">4.56</span>);<br>        Pair&lt;Integer&gt; p2 = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        setSame(p1, <span class="hljs-number">100</span>);<br>        setSame(p2, <span class="hljs-number">200</span>);<br>        System.out.println(p1.getFirst() + <span class="hljs-string">&quot;, &quot;</span> + p1.getLast());<br>        System.out.println(p2.getFirst() + <span class="hljs-string">&quot;, &quot;</span> + p2.getLast());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSame</span><span class="hljs-params">(Pair&lt;? <span class="hljs-keyword">super</span> Integer&gt; p, Integer n)</span> </span>&#123;<br>        p.setFirst(n);<br>        p.setLast(n);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(T first)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLast</span><span class="hljs-params">(T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>考察<code>Pair&lt;? super Integer&gt;</code>的<code>setFirst()</code>方法，它的方法签名实际上是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(? <span class="hljs-keyword">super</span> Integer)</span></span>;<br></code></pre></td></tr></table></figure><p>因此，可以安全地传入<code>Integer</code>类型。</p><p>再考察<code>Pair&lt;? super Integer&gt;</code>的<code>getFirst()</code>方法，它的方法签名实际上是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">? <span class="hljs-function"><span class="hljs-keyword">super</span> Integer <span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>这里注意到我们无法使用<code>Integer</code>类型来接收<code>getFirst()</code>的返回值，即下面的语句将无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = p.getFirst();<br></code></pre></td></tr></table></figure><p>因为如果传入的实际类型是<code>Pair&lt;Number&gt;</code>，编译器无法将<code>Number</code>类型转型为<code>Integer</code>。</p><p>注意：虽然<code>Number</code>是一个抽象类，我们无法直接实例化它。但是，即便<code>Number</code>不是抽象类，这里仍然无法通过编译。此外，传入<code>Pair&lt;Object&gt;</code>类型时，编译器也无法将<code>Object</code>类型转型为<code>Integer</code>。</p><p>唯一可以接收<code>getFirst()</code>方法返回值的是<code>Object</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object obj = p.getFirst();<br></code></pre></td></tr></table></figure><p>因此，使用<code>&lt;? super Integer&gt;</code>通配符表示：</p><ul><li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li><li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li></ul><p>==唯一例外是可以获取<code>Object</code>的引用==：<code>Object o = p.getFirst()</code>。</p><p>换句话说，使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对==于参数只能写，不能读==。</p><h5 id="对比extends和super通配符"><a href="#对比extends和super通配符" class="headerlink" title="对比extends和super通配符"></a>对比extends和super通配符</h5><p>我们再回顾一下<code>extends</code>通配符。作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p><ul><li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li><li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li></ul><p><strong>一个是允许读不允许写，另一个是允许写不允许读。</strong></p><p>==<strong>修正了一下，super不能用在class定义处，只能用在方法参数</strong>==</p><p>先记住上面的结论，我们来看Java标准库的<code>Collections</code>类定义的<code>copy()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            T t = src.get(i);<br>            dest.add(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的作用是把一个<code>List</code>的每个元素依次添加到另一个<code>List</code>中。它的第一个参数是<code>List&lt;? super T&gt;</code>，表示目标<code>List</code>，第二个参数<code>List&lt;? extends T&gt;</code>，表示要复制的<code>List</code>。我们可以简单地用<code>for</code>循环实现复制。在<code>for</code>循环中，我们可以看到，对于类型<code>&lt;? extends T&gt;</code>的变量<code>src</code>，我们可以安全地获取类型<code>T</code>的引用，而对于类型<code>&lt;? super T&gt;</code>的变量<code>dest</code>，我们可以安全地传入<code>T</code>的引用。</p><p>这个<code>copy()</code>方法的定义就完美地展示了<code>extends</code>和<code>super</code>的意图：</p><ul><li><code>copy()</code>方法内部不会读取<code>dest</code>，因为不能调用<code>dest.get()</code>来获取<code>T</code>的引用；</li><li><code>copy()</code>方法内部也不会修改<code>src</code>，因为不能调用<code>src.add(T)</code>。</li></ul><p>这是由编译器检查来实现的。如果在方法代码中意外修改了<code>src</code>，或者意外读取了<code>dest</code>，就会导致一个编译错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>        ...<br>        T t = dest.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// compile error!</span><br>        src.add(t); <span class="hljs-comment">// compile error!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>copy()</code>方法的另一个好处是可以安全地把一个<code>List&lt;Integer&gt;</code>添加到<code>List&lt;Number&gt;</code>，但是无法反过来添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// copy List&lt;Integer&gt; to List&lt;Number&gt; ok:</span><br>List&lt;Number&gt; numList = ...;<br>List&lt;Integer&gt; intList = ...;<br>Collections.copy(numList, intList);<br><br><span class="hljs-comment">// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:</span><br>Collections.copy(intList, numList);<br></code></pre></td></tr></table></figure><p>而这些都是通过<code>super</code>和<code>extends</code>通配符，并由编译器强制检查来实现的。</p><h5 id="PECS原则"><a href="#PECS原则" class="headerlink" title="==PECS原则=="></a>==PECS原则==</h5><p>何时使用<code>extends</code>，何时使用<code>super</code>？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。</p><p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p><p>还是以<code>Collections</code>的<code>copy()</code>方法为例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Collections &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-keyword">copy</span>(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? <span class="hljs-keyword">extends</span> T&gt; src) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;src.<span class="hljs-keyword">size</span>(); i++) &#123;<br>            T t = src.get(i); <span class="hljs-comment">// src是producer</span><br>            dest.add(t); <span class="hljs-comment">// dest是consumer</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>==需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。==</p><h5 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h5><p>我们已经讨论了<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code>?</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">sample</span>(<span class="hljs-params">Pair&lt;?&gt; p</span>)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p><ul><li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li><li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li></ul><p>换句话说，既不能读，也不能写，那只能做一些<code>null</code>判断：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isNull</span>(<span class="hljs-params">Pair&lt;?&gt; p</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> p.getFirst() == <span class="hljs-literal">null</span> || p.getLast() == <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数情况下，可以引入泛型参数<code>&lt;T&gt;</code>消除<code>&lt;?&gt;</code>通配符：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isNull</span>(<span class="hljs-params">Pair&lt;T&gt; p</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> p.getFirst() == <span class="hljs-literal">null</span> || p.getLast() == <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pair&lt;Integer&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>        Pair&lt;?&gt; p2 = p; <span class="hljs-comment">// 安全地向上转型</span><br>        System.out.println(p2.getFirst() + <span class="hljs-string">&quot;, &quot;</span> + p2.getLast());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(T first)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLast</span><span class="hljs-params">(T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码是可以正常编译运行的，因为<code>Pair&lt;Integer&gt;</code>是<code>Pair&lt;?&gt;</code>的子类，可以安全地向上转型。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>使用类似<code>&lt;? super Integer&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用传入<code>Integer</code>引用的方法，例如：<code>obj.setFirst(Integer n);</code>；</li><li>方法内部无法调用获取<code>Integer</code>引用的方法（<code>Object</code>除外），例如：<code>Integer n = obj.getFirst();</code>。</li></ul><p>即使用<code>super</code>通配符表示只能写不能读。</p><p>使用<code>extends</code>和<code>super</code>通配符要遵循PECS原则。</p><p>无限定通配符<code>&lt;?&gt;</code>很少使用，可以用<code>&lt;T&gt;</code>替换，同时它是所有<code>&lt;T&gt;</code>类型的超类。</p><h4 id="7-泛型和反射"><a href="#7-泛型和反射" class="headerlink" title="7.泛型和反射"></a>7.泛型和反射</h4><p>ava的部分反射API也是泛型。例如：<code>Class&lt;T&gt;</code>就是泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// compile warning:</span><br>Class clazz = String.class;<br>String str = (String) clazz.newInstance();<br><br><span class="hljs-comment">// no warning:</span><br>Class&lt;String&gt; clazz = String.class;<br>String str = clazz.newInstance();<br></code></pre></td></tr></table></figure><p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;? <span class="hljs-keyword">super</span> String&gt; sup = String.class.getSuperclass();<br></code></pre></td></tr></table></figure><p>构造方法<code>Constructor&lt;T&gt;</code>也是泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Integer&gt; clazz = Integer.class;<br>Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class="hljs-keyword">int</span>.class);<br>Integer i = cons.newInstance(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>我们可以声明带泛型的数组，但不能用<code>new</code>操作符创建带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt;[] ps = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// ok</span><br>Pair&lt;String&gt;[] ps = <span class="hljs-keyword">new</span> Pair&lt;String&gt;[<span class="hljs-number">2</span>]; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><p>必须通过强制转型实现带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="hljs-keyword">new</span> Pair[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量<code>ps</code>，因为它的类型是泛型数组。但是，编译器不会检查变量<code>arr</code>，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作<code>arr</code>可能导致从<code>ps</code>获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair[] arr = <span class="hljs-keyword">new</span> Pair[<span class="hljs-number">2</span>];<br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;<br><br>ps[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;String&gt;(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// ClassCastException:</span><br>Pair&lt;String&gt; p = ps[<span class="hljs-number">1</span>];<br>String s = p.getFirst();<br></code></pre></td></tr></table></figure><p>要安全地使用泛型数组，必须扔掉<code>arr</code>的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="hljs-keyword">new</span> Pair[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code>ps</code>进行操作，这种操作就是安全的。</p><p>带泛型的数组实际上是编译器的类型擦除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair[] arr = <span class="hljs-keyword">new</span> Pair[<span class="hljs-number">2</span>];<br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;<br><br>System.out.println(ps.getClass() == Pair[].class); <span class="hljs-comment">// true</span><br><br>String s1 = (String) arr[<span class="hljs-number">0</span>].getFirst();<br>String s2 = ps[<span class="hljs-number">0</span>].getFirst();<br></code></pre></td></tr></table></figure><p>所以我们不能直接创建泛型数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// compile error:</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Abc</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    T[] createArray() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T[<span class="hljs-number">5</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>必须借助<code>Class&lt;T&gt;</code>来创建泛型数组：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">T[] createArray(Class&lt;T&gt; cls) &#123;<br>    <span class="hljs-keyword">return</span> (T[]) Array.newInstance(cls, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们还可以利用可变参数创建泛型数组<code>T[]</code>：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayHelper</span> </span>&#123;<br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>        <span class="hljs-keyword">return</span> objs;<br>    &#125;<br>&#125;<br><br>String[] ss = ArrayHelper.asArray(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>Integer[] ns = ArrayHelper.asArray(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h5 id="谨慎使用泛型可变参数"><a href="#谨慎使用泛型可变参数" class="headerlink" title="谨慎使用泛型可变参数"></a>谨慎使用泛型可变参数</h5><p>在上面的例子中，我们看到，通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>    <span class="hljs-keyword">return</span> objs;<br>&#125;<br></code></pre></td></tr></table></figure><p>似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String[] arr = asArray(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        System.out.println(Arrays.toString(arr));<br>        <span class="hljs-comment">// ClassCastException:</span><br>        String[] firstTwo = pickTwo(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>);<br>        System.out.println(Arrays.toString(firstTwo));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) &#123;<br>        <span class="hljs-keyword">return</span> asArray(k1, k2);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>        <span class="hljs-keyword">return</span> objs;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接调用<code>asArray(T...)</code>似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生<code>ClassCastException</code>，原因还是因为擦拭法，在<code>pickTwo()</code>方法内部，编译器无法检测<code>K[]</code>的正确类型，因此返回了<code>Object[]</code>。</p><p>如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用<code>@SafeVarargs</code>消除警告。</p><p>==如果在方法内部创建了泛型数组，最好不要将它返回给外部使用==</p><h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><ul><li><p>部分反射API是泛型，例如：<code>Class&lt;T&gt;</code>，<code>Constructor&lt;T&gt;</code>；</p></li><li><p>可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；</p></li><li><p>可以通过<code>Array.newInstance(Class&lt;T&gt;, int)</code>创建<code>T[]</code>数组，需要强制转型；</p></li><li><p>同时使用泛型和可变参数时需要特别小心。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程学习</title>
    <link href="/2021/10/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/10/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="多线程的学习"><a href="#多线程的学习" class="headerlink" title="多线程的学习"></a>多线程的学习</h2><h3 id="1-目录"><a href="#1-目录" class="headerlink" title="1.目录"></a>1.目录</h3><p><img src="/images/Thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%AE%E5%BD%95.png"></p><h3 id="2-线程、进程、多线程"><a href="#2-线程、进程、多线程" class="headerlink" title="2.线程、进程、多线程"></a>2.线程、进程、多线程</h3><ol><li>线程(Thread)：线程就是独立的执行路径；</li><li>进程(process)：进程是执行程序的一次执行过程，它是一个动态的概念。<strong>是系统资源分配的单位</strong></li><li>一般一个进程中可以包括多个线程，当然一个进程中至少有一个线程，不然就没有存在的意义。<strong>线程是CPU调度和执行的单位</strong></li></ol><blockquote><p>注意：很多线程是模拟出来的，真正的多线程是只有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所有才有了同时执行的错觉。</p></blockquote><p><img src="/images/Thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E7%94%A8%E5%AF%B9%E6%AF%94.png"></p><ul><li>一个进程可以有多个线程，比如视频中有声音，弹幕，图像等等。</li></ul><h3 id="本章核心概念"><a href="#本章核心概念" class="headerlink" title="本章核心概念"></a>本章核心概念</h3><ul><li>线程就是独立的执行路径</li><li>在程序运行时，即使自己没有创建线程，后台也会有多个线程，比如主线程，gc线程(垃圾回收)</li><li>main()称之为主线程，为系统的入口，用于执行整个程序</li><li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的。</li><li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；</li><li>线程会带来额外的开销，如cpu调度时间，并发控制开销</li><li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li></ul><h3 id="3-线程的创建"><a href="#3-线程的创建" class="headerlink" title="3.线程的创建"></a>3.线程的创建</h3><h4 id="三种创建方式"><a href="#三种创建方式" class="headerlink" title="三种创建方式"></a>三种创建方式</h4><ul><li>Thread class        继承Thread类(重点)</li><li>Runnable接口       实现Runnable接口（重点）</li><li>Callable接口          实现Callable接口（了解即可，以后工作可能会用到）</li></ul><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><ul><li>自定义线程类继承 <strong>Thread类</strong></li><li>重写run()方法，编写方法体</li><li>创建线程对象，调用Start（）方法启动线程</li></ul><blockquote><p>线程不一定立刻执行，cpu安排调度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.demo01;<br><span class="hljs-comment">//创建线程的方法一：</span><br><span class="hljs-comment">//继承Thread类，重写run()方法，调用start开启线程</span><br><span class="hljs-comment">//总结：注意线程不一定立即执行，由CPU调度执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-comment">//重写run方法</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在看代码，重写run方法&quot;</span>+i);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//调用主线程main</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建一个线程对象</span><br>        TestThread testThread = <span class="hljs-keyword">new</span> TestThread();<br><br>        <span class="hljs-comment">//调用start()方法开启线程</span><br>        testThread.start();<br><br>        <span class="hljs-comment">//主线程运行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程  &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/Thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><p><strong>注意</strong></p><ul><li>可以看到是并发执行的。</li><li>调用的是start方法，不是run方法</li></ul><h4 id="网图下载"><a href="#网图下载" class="headerlink" title="网图下载"></a>网图下载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.demo01;<br><br><span class="hljs-keyword">import</span> org.apache.commons.io.FileUtils;<br><br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestThread2</span><span class="hljs-params">(String url, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.url = url;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        WebDownloader webDownloader = <span class="hljs-keyword">new</span> WebDownloader();<br>        <span class="hljs-keyword">try</span> &#123;<br>            webDownloader.download(url, name);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;下载的文件名：&quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        TestThread2 t1 = <span class="hljs-keyword">new</span> TestThread2(<span class="hljs-string">&quot;https://b-ssl.duitang.com/uploads/item/201612/07/20161207082313_mN2iJ.thumb.700_0.jpeg&quot;</span>, <span class="hljs-string">&quot;测试1.jpg&quot;</span>);<br>        TestThread2 t2 = <span class="hljs-keyword">new</span> TestThread2(<span class="hljs-string">&quot;https://ss3.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/6f061d950a7b0208d1ed7d8563d9f2d3572cc8aa.jpg&quot;</span>, <span class="hljs-string">&quot;测试2.jpg&quot;</span>);<br>        TestThread2 t3 = <span class="hljs-keyword">new</span> TestThread2(<span class="hljs-string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180505%2Fdab71918ecff4797afec962d88985406.jpeg&amp;refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1620268164&amp;t=a294065d113f9d2b3945c77eaf42ad56&quot;</span>, <span class="hljs-string">&quot;测试3.jpg&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//下载器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebDownloader</span></span>&#123;<br><br>    <span class="hljs-comment">//下载方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">download</span><span class="hljs-params">(String url,String name)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileUtils.copyURLToFile(<span class="hljs-keyword">new</span> URL(url), <span class="hljs-keyword">new</span> File(name));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;IO异常，download方法出现异常&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>导入一个jar包，commons io  可以百度搜索</li></ul><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.demo01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在看代码---&quot;</span> + i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br><br>        <span class="hljs-comment">//创建runnable接口的实现类对象</span><br>        TestThread3 testThread3 = <span class="hljs-keyword">new</span> TestThread3();<br>        <span class="hljs-comment">//创建线程对象，通过线程对象来开启我们的线程代理</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(testThread3);<br>        thread.start();<br><br><span class="hljs-comment">//        //或者等于</span><br><span class="hljs-comment">//        new Thread(testThread3).start();</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li><p>继承Thread类</p><ul><li>子类继承Thread类具备多线程能力</li><li>启动线程：子类对象.start()</li><li><strong>不建议使用：避免OOP单继承局限性</strong></li></ul></li><li><p>实现Runnable接口</p><ul><li>实现接口Runnable具有多线程能力</li><li>启动线程：传入目标对象+Thread对象.start()</li><li><strong>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</strong></li></ul></li></ul><p><img src="E:\dgut\blog\wjx002\source\images\Thread\runnable代理.png"></p><h3 id="初始并发问题"><a href="#初始并发问题" class="headerlink" title="初始并发问题"></a>初始并发问题</h3><ul><li>多个对象同时操作同一个对象</li><li>比如  买车票</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.demo01;<br><br><span class="hljs-comment">//初识并发问题</span><br><span class="hljs-comment">//多个线程同时操作一个对象</span><br><span class="hljs-comment">//例如：买车票</span><br><br><br><span class="hljs-comment">//发现问题，多个线程操作同一个资源时，线程不安全，数据紊乱。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread4</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-comment">//票数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticketNums = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ticketNums &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//模拟延时</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到了第&quot;</span> + ticketNums-- + <span class="hljs-string">&quot;票&quot;</span>);<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        TestThread4 ticket = <span class="hljs-keyword">new</span> TestThread4();<br>        <span class="hljs-keyword">new</span> Thread(ticket,<span class="hljs-string">&quot;小明&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(ticket,<span class="hljs-string">&quot;老师&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(ticket,<span class="hljs-string">&quot;黄牛党&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/images/Thread/%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%984.png"></p><ul><li>发现同一张票被多个人获取到了，这明显不符合火车票的规则，</li><li>线程不安全了，数据紊乱</li></ul><h3 id="龟兔赛跑"><a href="#龟兔赛跑" class="headerlink" title="龟兔赛跑"></a>龟兔赛跑</h3><p>案例：龟兔赛跑-Race</p><ol><li>首先定一个赛道距离，然后要离终点越来越近</li><li>判断比赛是否结束</li><li>打印出胜利者</li><li>龟兔赛跑开始</li><li>故事中是乌龟赢的，兔子要睡觉，所以我们来模拟兔子睡觉</li><li>终于，乌龟赢得了比赛</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.demo01;<br><br><span class="hljs-comment">//龟兔赛跑</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 首先定一个赛道距离，然后要离终点越来越近</span><br><span class="hljs-comment">2. 判断比赛是否结束</span><br><span class="hljs-comment">3. 打印出胜利者</span><br><span class="hljs-comment">4. 龟兔赛跑开始</span><br><span class="hljs-comment">5. 故事中是乌龟赢的，兔子要睡觉，所以我们来模拟兔子睡觉</span><br><span class="hljs-comment">6. 终于，乌龟赢得了比赛</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Race</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String winner;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br><br>            <span class="hljs-comment">//模拟一下兔子休息</span><br>            <span class="hljs-keyword">if</span> (Thread.currentThread().getName().equals(<span class="hljs-string">&quot;兔子&quot;</span>) &amp;&amp; i % <span class="hljs-number">20</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1</span>);<br>                    System.out.println(<span class="hljs-string">&quot;兔子想睡觉&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>            &#125;<br><br>            <span class="hljs-comment">//判断是否游戏结束，true则是出现胜利者了</span><br>            <span class="hljs-keyword">boolean</span> flag = gameOver(i);<br>            <span class="hljs-keyword">if</span> (flag) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//兔子速度比较快</span><br>            <span class="hljs-keyword">if</span> (Thread.currentThread().getName().equals(<span class="hljs-string">&quot;兔子&quot;</span>)) &#123;<br>                i+=<span class="hljs-number">5</span>;<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;跑了-----&gt;&quot;</span>+i+<span class="hljs-string">&quot;步&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">gameOver</span><span class="hljs-params">(<span class="hljs-keyword">int</span> steps)</span> </span>&#123;<br><br>        <span class="hljs-comment">//判断有没有胜利者</span><br>        <span class="hljs-keyword">if</span> (winner != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//出现胜利者了</span><br>        <span class="hljs-keyword">if</span> (steps == <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-comment">//获取胜利者名字</span><br>            winner = Thread.currentThread().getName();<br>            <span class="hljs-comment">//输出胜利者是谁</span><br>            System.out.println(<span class="hljs-string">&quot;winner is &quot;</span> + winner);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Race race = <span class="hljs-keyword">new</span> Race();<br>        <span class="hljs-keyword">new</span> Thread(race,<span class="hljs-string">&quot;兔子&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(race,<span class="hljs-string">&quot;乌龟&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/images/Thread/%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91.png"></p><h3 id="实现Callable接口（了解即可）"><a href="#实现Callable接口（了解即可）" class="headerlink" title="实现Callable接口（了解即可）"></a>实现Callable接口（了解即可）</h3><ol><li>实现Callable接口，需要返回值类型</li><li>重写call方法，需要抛出异常</li><li>创建目标对象</li><li>创建执行服务</li><li>提交执行</li><li>获取结果</li><li>关闭服务</li></ol><p><img src="/images/Thread/Callable.png"></p><p><strong>好处</strong></p><ul><li>可以抛出异常</li><li>获取返回值</li></ul><h3 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h3><p><strong>总结：</strong></p><ul><li>真实对象和代理对象都要实现同一个接口</li><li>代理对象要代理真实角色</li></ul><p><strong>好处：</strong></p><ul><li>代理对象可以做很多真实对象做不了的事情</li><li>真实对象专注于做自己的事情</li></ul><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ul><li><p>λ希腊字母表中排序第十一位的字母，英语名称lambda</p></li><li><p>避免匿名内部类定义过多</p></li><li><p>其实质属于函数式编程的概念</p><ul><li>(params)-&gt;expression[表达式]</li><li>(params) -&gt; statement[语句]</li><li>(params) -&gt; {statements}</li></ul></li><li><p>为什么要使用lamda表达式</p><ul><li>避免匿名内部类定义过多</li><li>可以使你的代码更简洁</li><li>去除掉一些没有意义的代码，只剩下核心的逻辑部分</li></ul></li><li><p>理解Functional Interface(函数式接口) 是学习java8 lambda表达式的关键所在</p></li><li><p>函数式接口的定义：</p><ul><li>任何接口，如果只包含唯一一个抽象方法，那么他就是一个函数式接口<ul><li>public interface Runnable{</li><li>abstract void Run（）;</li><li>}</li></ul></li><li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lambda;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLambda</span> </span>&#123;<br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Like2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">iLove</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">love</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;我喜欢1&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//局部内部类</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Like3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">iLove</span> </span>&#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">love</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;我喜欢2&quot;</span>);<br>            &#125;<br>        &#125;<br><br><br>        iLove like = <span class="hljs-keyword">new</span> Like();<br>        like.love();<br>        like = <span class="hljs-keyword">new</span> Like2();<br>        like.love();<br>        like = <span class="hljs-keyword">new</span> Like3();<br>        like.love();<br><br>        <span class="hljs-comment">//匿名内部类：没有类的名称，必须借助接口或者父类</span><br>        like = <span class="hljs-keyword">new</span> iLove() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">love</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;我喜欢333&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        like = ()-&gt; System.out.println(<span class="hljs-string">&quot;我喜欢22&quot;</span>);<br><br>        <span class="hljs-comment">//总结：</span><br>        <span class="hljs-comment">//lambda表达式只能在一行代码的情况下才能简化成为一行，如果有多行，那么就用代码块包裹</span><br>        <span class="hljs-comment">//前提接口是函数式接口，就是接口里只有一个函数</span><br>        <span class="hljs-comment">//多个函数也可以去掉参数类型，要去掉就都去掉，必须加上括号</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">iLove</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">love</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//首先可以是内部类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Like</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">iLove</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">love</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我喜欢&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>//总结：<pre><code>//lambda表达式只能在一行代码的情况下才能简化成为一行，如果有多行，那么就用代码块包裹//前提接口是函数式接口，就是接口里只有一个函数//多个函数也可以去掉参数类型，要去掉就都去掉，必须加上括号</code></pre></li></ul><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>五个状态：</p><ul><li>创建状态</li><li>就绪状态</li><li>阻塞状态</li><li>运行状态</li><li>死亡状态</li></ul><h4 id="线程的转换过程"><a href="#线程的转换过程" class="headerlink" title="线程的转换过程"></a>线程的转换过程</h4><p><img src="/images/Thread/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"></p><p><img src="/images/Thread/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%AE%9E%E9%99%85%E8%BD%AC%E6%8D%A2.png"></p><h4 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setPriority（int newPriority)</td><td>更改线程的优先级</td></tr><tr><td>static void sleep(long millis)</td><td>在指定的毫秒内让当前正在执行的线程休眠</td></tr><tr><td>void join()</td><td>等待该线程终止</td></tr><tr><td>static void yield()</td><td>暂停当前正在执行的线程对象，并执行其他线程</td></tr><tr><td>void interrupt()</td><td>中断线程，别用这种方式</td></tr><tr><td>boolean isAlive()</td><td>测试线程是否处于活动状态</td></tr></tbody></table><h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4><p><img src="/images/Thread/%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.state;<br><br><br><span class="hljs-comment">//测试stop</span><br><span class="hljs-comment">//1.建议线程正常停止----&gt;利用次数，不建议死循环</span><br><span class="hljs-comment">//建议使用标志位-----&gt;设置一个标志位</span><br><span class="hljs-comment">//3.不要使用stop或者destroy等过时或者JDk不建议使用的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testStop</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br><br>    <span class="hljs-comment">//1.设置一个标志位</span><br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br><br><br>    <span class="hljs-comment">//转换标志位</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            System.out.println(<span class="hljs-string">&quot;run Thread &quot;</span> + i++);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建线程对象</span><br>        testStop testStop = <span class="hljs-keyword">new</span> testStop();<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(testStop);<br>        <span class="hljs-comment">//开启线程</span><br>        thread.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;main线程&quot;</span> + i);<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">9900</span>) &#123;<br>                <span class="hljs-comment">//当主线程i等于990时，停止线程</span><br>                testStop.stop();<br>                System.out.println(<span class="hljs-string">&quot;线程终止了&quot;</span>);<br>            &#125;<br><br>            ;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h4><p><img src="/images/Thread/%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0.png"></p><ul><li>sleep(时间) 指定当前线程的阻塞的毫秒数</li><li>sleeo存在异常interruptedException</li><li>sleep时间达到后线程进入就绪状态</li><li>sleep时间可以模拟网络延时，倒计时等</li><li>每个对象都有一个锁lock，sleep不会释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.state;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">//模拟倒计时</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testSleep2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">timeDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(num--);<br><br>            <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//打印当前系统时间</span><br>        <span class="hljs-comment">//获取当前系统时间</span><br>        Date startTime = <span class="hljs-keyword">new</span> Date(System.currentTimeMillis());<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(startTime));<br><br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                startTime = <span class="hljs-keyword">new</span> Date(System.currentTimeMillis());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.state;<br><br><span class="hljs-comment">//模拟网络延时: 放大问题的发生性</span><br><br><br><span class="hljs-keyword">import</span> com.jiaxu.demo01.Race;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testSleep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-comment">//票数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticketNums = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (ticketNums &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br><br>            &#125;<br>            <span class="hljs-comment">//模拟延时</span><br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到了第&quot;</span> + ticketNums-- + <span class="hljs-string">&quot;票&quot;</span>);<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        testSleep testSleep = <span class="hljs-keyword">new</span> testSleep();<br>        <span class="hljs-keyword">new</span> Thread(testSleep,<span class="hljs-string">&quot;小米&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(testSleep,<span class="hljs-string">&quot;老师&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(testSleep, <span class="hljs-string">&quot;黄牛党&quot;</span>).start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h4><ul><li>礼让线程，让当前正在执行的线程暂停，但是不阻塞</li><li>将线程从运行 状态转为就绪状态</li><li><strong>让cpu重新调度，礼让不一定成功！！！看CPU心情</strong></li></ul><p><strong>Thread.yield</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.state;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testYield</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyYield myYield = <span class="hljs-keyword">new</span> MyYield();<br><br>        <span class="hljs-keyword">new</span> Thread(myYield, <span class="hljs-string">&quot;a&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(myYield, <span class="hljs-string">&quot;b&quot;</span>).start();<br>        <br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyYield</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程开始执行&quot;</span>);<br>        <span class="hljs-comment">//线程礼让</span><br>        Thread.yield();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程终止执行&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>线程礼让</li></ul><p><img src="/images/Thread/%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9.png"></p><ul><li>不礼让的情况下</li></ul><p><img src="/images/Thread/%E4%B8%8D%E7%A4%BC%E8%AE%A9.png"></p><h4 id="线程强制执行"><a href="#线程强制执行" class="headerlink" title="线程强制执行"></a>线程强制执行</h4><p><strong>Join</strong></p><ul><li>Join合并线程，待此线程执行完毕，再执行其他线程，其他线程阻塞</li><li>可以想象成插队</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.state;<br><br><span class="hljs-comment">//测试join方法</span><br><span class="hljs-comment">//想象成插队</span><br><br><span class="hljs-keyword">import</span> com.sun.javafx.sg.prism.web.NGWebView;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testJoin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br><br>            System.out.println(<span class="hljs-string">&quot;线程vip来了&quot;</span> + i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        testJoin testJoin = <span class="hljs-keyword">new</span> testJoin();<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(testJoin);<br>        thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">200</span>) &#123;<br>                thread.join();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;main线程&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程观测状态"><a href="#线程观测状态" class="headerlink" title="线程观测状态"></a>线程观测状态</h4><p><img src="/images/Thread/%E7%BA%BF%E7%A8%8B%E8%A7%82%E6%B5%8B%E8%BD%AC%E6%80%81.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.state;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testState</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <br><br>            System.out.println(<span class="hljs-string">&quot;//////////&quot;</span>);<br><br>        &#125;);<br><br><br>        <span class="hljs-comment">//观察状态</span><br>        Thread.State state = thread.getState();<br>        <span class="hljs-comment">//输出状态</span><br>        System.out.println(state);<br><br>        <span class="hljs-comment">//观察启动后</span><br>        thread.start();<br>        state = thread.getState();<span class="hljs-comment">//更新状态</span><br>        System.out.println(state);<br><br>        <span class="hljs-comment">//只要线程不结束，则一直输出线程状态</span><br>        <span class="hljs-keyword">while</span> (state != Thread.State.TERMINATED) &#123;<br><br><br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//更新线程状态</span><br>            state = thread.getState();<br>            <span class="hljs-comment">//输出线程状态</span><br>            System.out.println(state);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>死亡状态后不可以在启动线程 了</strong></p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p><img src="/images/Thread/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.png"></p><ul><li>线程优先级高不一定先执行，只不过是执行的可能性高了</li><li>看cpu调度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.state;<br><span class="hljs-comment">//测试线程的优先级</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testPriority</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//主线程默认优先级</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;----&gt;&quot;</span> + Thread.currentThread().getPriority());<br><br>        MyPriority myPriority = <span class="hljs-keyword">new</span> MyPriority();<br><br>        Thread thread1 = <span class="hljs-keyword">new</span> Thread(myPriority);<br>        Thread thread2 = <span class="hljs-keyword">new</span> Thread(myPriority);<br>        Thread thread3 = <span class="hljs-keyword">new</span> Thread(myPriority);<br>        Thread thread4 = <span class="hljs-keyword">new</span> Thread(myPriority);<br>        Thread thread5 = <span class="hljs-keyword">new</span> Thread(myPriority);<br>        Thread thread6 = <span class="hljs-keyword">new</span> Thread(myPriority);<br><br>        <span class="hljs-comment">//设置优先级，在启动</span><br>        thread1.start();<br><br>        thread2.setPriority(<span class="hljs-number">1</span>);<br>        thread2.start();<br>        <br><br>        thread3.setPriority(Thread.MAX_PRIORITY);<br>        thread3.start();<br><br>        thread4.setPriority(<span class="hljs-number">7</span>);<br>        thread4.start();<br><br>        thread5.setPriority(<span class="hljs-number">4</span>);<br>        thread5.start();<br><br>        thread6.setPriority(<span class="hljs-number">3</span>);<br>        thread6.start();<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPriority</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//输出线程的优先级</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-----&gt;&quot;</span> + Thread.currentThread().getPriority());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码显示结果</strong></p><p><img src="/images/Thread/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%AF%94%E8%BE%83.png"></p><h4 id="守护线程（daemon）"><a href="#守护线程（daemon）" class="headerlink" title="守护线程（daemon）"></a>守护线程（daemon）</h4><ul><li>线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕（gc垃圾回收）</li><li>如后台记录操作日志、监控内存、垃圾回收等待..</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.state;<br><br><span class="hljs-comment">//测试守护线程</span><br><span class="hljs-comment">//上帝保护你</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testDaemon</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        God god = <span class="hljs-keyword">new</span> God();<br>        You you = <span class="hljs-keyword">new</span> You();<br><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(god);<br>        thread.setDaemon(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//默认是false表示是用户线程</span><br>        <span class="hljs-comment">//正常线程都是用户线程</span><br><br>        thread.start();<span class="hljs-comment">//开启守护线程</span><br>        <span class="hljs-keyword">new</span> Thread(you).start();<span class="hljs-comment">//开启用户线程...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//上帝</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">God</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;上帝保佑你&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//你</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">36500</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;你开心的活着&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;=========goodbye! world!======&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul><li>多个线程操作同一个资源</li><li>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步，线程同步就是一种等待机制，多个需要同时访问此对象的线程进入到这个<strong>对象的线程池</strong>形成队列，等待前面线程使用完毕，下一个线程再使用</li><li>由于同一进程的多个线程共享一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问的正确性，在访问是加入<strong>锁机制 synchronized</strong>，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题<ul><li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li><li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换 ，和 调度延时，引起性能问题；</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题</li></ul></li></ul><h5 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h5><ul><li>同一个对象被多个线程同时操作</li></ul><h5 id="队列和锁"><a href="#队列和锁" class="headerlink" title="队列和锁"></a>队列和锁</h5><ul><li>保证线程同步的安全性</li></ul><h4 id="三大不安全案例"><a href="#三大不安全案例" class="headerlink" title="三大不安全案例"></a>三大不安全案例</h4><ul><li>买车票</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.syncronized;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnselfBuyTicket</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BuyTicket buyTicket = <span class="hljs-keyword">new</span> BuyTicket();<br>        <span class="hljs-keyword">new</span> Thread(buyTicket,<span class="hljs-string">&quot;小米&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(buyTicket,<span class="hljs-string">&quot;小孩&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(buyTicket,<span class="hljs-string">&quot;黄牛&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuyTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-comment">//票数</span><br>    <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//标志位</span><br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//买票</span><br>        <span class="hljs-keyword">if</span> (ticket &lt;= <span class="hljs-number">0</span>) &#123;<br>            flag = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//模拟延时</span><br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//买一张就少一张</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;买了第&quot;</span> + ticket-- + <span class="hljs-string">&quot;张票&quot;</span>);<br><br><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (flag) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                buy();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>银行取钱</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.syncronized;<br><br><span class="hljs-comment">//不安全的取钱</span><br><span class="hljs-comment">//两个人去银行取钱</span><br><br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.generic.NEW;<br><br><span class="hljs-keyword">import</span> java.awt.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeBank</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Account account = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;结婚基金&quot;</span>);<br><br>        Drawing wo = <span class="hljs-keyword">new</span> Drawing(account, <span class="hljs-number">50</span>, <span class="hljs-string">&quot;wo&quot;</span>);<br>        Drawing girl = <span class="hljs-keyword">new</span> Drawing(account, <span class="hljs-number">100</span>,<span class="hljs-string">&quot;girl&quot;</span>);<br><br>        wo.start();<br>        girl.start();<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//账户</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">//余额</span><br>    <span class="hljs-keyword">int</span> money;<br>    <span class="hljs-comment">//卡名</span><br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//银行：模拟取款</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawing</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    Account account;<span class="hljs-comment">//取钱账户</span><br><br>    <span class="hljs-comment">//取了多少钱</span><br>    <span class="hljs-keyword">int</span> drawingMoney;<br><br>    <span class="hljs-comment">//手里有多少钱</span><br>    <span class="hljs-keyword">int</span> nowMoney;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Drawing</span><span class="hljs-params">(Account account, <span class="hljs-keyword">int</span> drawingMoney, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.account = account;<br>        <span class="hljs-keyword">this</span>.drawingMoney = drawingMoney;<br><br>    &#125;<br><br><br><br>    <span class="hljs-comment">//取钱</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">//判断有没有钱</span><br>        <span class="hljs-keyword">if</span> (account.money - drawingMoney &lt; <span class="hljs-number">0</span>) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;钱不够了&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">//卡的余额 = 余额 - 你取的钱</span><br>        account.money = account.money - drawingMoney;<br>        <span class="hljs-comment">//手里的钱</span><br><br>        nowMoney = nowMoney + drawingMoney;<br>        System.out.println(account.name + <span class="hljs-string">&quot;余额为：&quot;</span> + account.money);<br><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;手里的钱&quot;</span> + nowMoney);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>list</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.syncronized;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeList</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                list.add(Thread.currentThread().getName());<br>            &#125;).start();<br><br>        &#125;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(list.size());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><ul><li>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对一天机制，这套机制就是synchronized关键字，他包括两种用法：<ul><li>synchronized方法和synchronized块</li><li>同步方法：public synchronized void method（int args）{}</li></ul></li><li>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，后面被阻塞的线程才能获得这个锁，继续执行<ul><li>缺陷：若将一个大的方法申明为synchronized将影响效率</li></ul></li></ul><h4 id="同步方法弊端"><a href="#同步方法弊端" class="headerlink" title="同步方法弊端"></a>同步方法弊端</h4><p><img src="/images/Thread/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%BC%8A%E7%AB%AF.png"></p><h4 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h4><p><img src="E:\dgut\blog\wjx002\source\images\Thread\同步块.png"></p><p><strong>锁的对象是要修改的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (list) &#123;<br>    list.add(Thread.currentThread().getName());<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才可以运行，而且导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有<strong>两个以上对象的锁</strong>时，就可能发生”死锁“的问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lock;<br><br><span class="hljs-comment">//死锁：一个同步块拥有两个或两个以上的对象的锁，才有可能发生</span><br><span class="hljs-comment">//互相占有其他线程需要的资源，等待其他线程释放资源才可以运行，</span><br><span class="hljs-comment">//导致停止执行的情形</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        MakeUp person1 = <span class="hljs-keyword">new</span> MakeUp(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;火姑娘&quot;</span>);<br>        MakeUp person2 = <span class="hljs-keyword">new</span> MakeUp(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;白雪公主&quot;</span>);<br><br>        person1.start();<br>        person2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//化妆品类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lipstick</span></span>&#123;<br><br>&#125;<br><br><br><span class="hljs-comment">//镜子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mirror</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//化妆执行</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MakeUp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    <span class="hljs-comment">//保证需要的资源只有一份，用static来保证只有一份</span><br>    <span class="hljs-keyword">static</span> Lipstick lipstick = <span class="hljs-keyword">new</span> Lipstick();<br>    <span class="hljs-keyword">static</span> Mirror mirror = <span class="hljs-keyword">new</span> Mirror();<br><br>    <span class="hljs-comment">//选择</span><br>    <span class="hljs-keyword">int</span> choice;<br>    <span class="hljs-comment">//化妆的人</span><br>    String girl;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MakeUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> choice, String girl)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.choice = choice;<br>        <span class="hljs-keyword">this</span>.girl = girl;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//运行化妆方法</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            makeup();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//化妆方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span> (choice == <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-comment">//开始化妆</span><br>            <span class="hljs-keyword">synchronized</span> (lipstick) &#123;<br>                <span class="hljs-comment">//获取到了口红的锁</span><br>                System.out.println(<span class="hljs-keyword">this</span>.girl + <span class="hljs-string">&quot;拿到了口红的锁&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (mirror) &#123;<br>                    <span class="hljs-comment">//获取到了镜子的锁</span><br>                    System.out.println(<span class="hljs-keyword">this</span>.girl + <span class="hljs-string">&quot;拿到了镜子的锁&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//开始化妆</span><br>            <span class="hljs-keyword">synchronized</span> (mirror) &#123;<br>                <span class="hljs-comment">//获取到了镜子的锁</span><br>                System.out.println(<span class="hljs-keyword">this</span>.girl + <span class="hljs-string">&quot;拿到了镜子的锁&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">synchronized</span> (lipstick) &#123;<br>                    <span class="hljs-comment">//获取到了口红的锁</span><br>                    System.out.println(<span class="hljs-keyword">this</span>.girl + <span class="hljs-string">&quot;拿到了口红的锁&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样就发生了死锁、</p></blockquote><p><img src="/images/Thread/%E6%AD%BB%E9%94%81.png"></p><blockquote><p>一个同步块里面有了两个对象的锁，并且还互相持有对方的资源不放手，导致程序停止</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (choice == <span class="hljs-number">0</span>) &#123;<br><br>           <span class="hljs-comment">//开始化妆</span><br>           <span class="hljs-keyword">synchronized</span> (lipstick) &#123;<br>               <span class="hljs-comment">//获取到了口红的锁</span><br>               System.out.println(<span class="hljs-keyword">this</span>.girl + <span class="hljs-string">&quot;拿到了口红的锁&quot;</span>);<br>               Thread.sleep(<span class="hljs-number">1000</span>);<br><br>           &#125;<br>           <span class="hljs-keyword">synchronized</span> (mirror) &#123;<br>               <span class="hljs-comment">//获取到了镜子的锁</span><br>               System.out.println(<span class="hljs-keyword">this</span>.girl + <span class="hljs-string">&quot;拿到了镜子的锁&quot;</span>);<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//开始化妆</span><br>           <span class="hljs-keyword">synchronized</span> (mirror) &#123;<br>               <span class="hljs-comment">//获取到了镜子的锁</span><br>               System.out.println(<span class="hljs-keyword">this</span>.girl + <span class="hljs-string">&quot;拿到了镜子的锁&quot;</span>);<br>               Thread.sleep(<span class="hljs-number">1000</span>);<br><br>           &#125;<br>           <span class="hljs-keyword">synchronized</span> (lipstick) &#123;<br>               <span class="hljs-comment">//获取到了口红的锁</span><br>               System.out.println(<span class="hljs-keyword">this</span>.girl + <span class="hljs-string">&quot;拿到了口红的锁&quot;</span>);<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><blockquote><p>解决方法就是使同一个代码块里不要有互相持有对方资源的多个对象</p></blockquote><p><img src="/images/Thread/%E4%B8%8D%E6%AD%BB%E9%94%81.png" alt="正常应该的运行"></p><h4 id="死锁避免方法"><a href="#死锁避免方法" class="headerlink" title="死锁避免方法"></a>死锁避免方法</h4><ul><li>产生死锁的四个必要条件：<ul><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件：进程已获得的资源，在未使用完前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾衔接的循环等待资源关系。</li></ul></li></ul><p><strong>只要我们破获其中的任意一种或多个条件就可以避免死锁的发生</strong></p><h3 id="lock（锁）"><a href="#lock（锁）" class="headerlink" title="lock（锁）"></a>lock（锁）</h3><ul><li>从JDK5.0开始，java提供了更强大的线程同步机制——通过显示定义同步锁对象来实现同步。同步锁使用Lock对象充当</li><li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象进行加锁，线程开始访问共享资源之前应先获得Lock对象</li><li>ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁，释放锁。</li></ul><blockquote><p>ReentrantLock  可重入锁</p></blockquote><p><img src="/images/Thread/%E9%94%81.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lock;<br><br><span class="hljs-keyword">import</span> java.text.BreakIterator;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">reenTrantLock</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BuyTickey buyTickey = <span class="hljs-keyword">new</span> BuyTickey();<br>        <span class="hljs-keyword">new</span> Thread(buyTickey).start();<br>        <span class="hljs-keyword">new</span> Thread(buyTickey).start();<br>        <span class="hljs-keyword">new</span> Thread(buyTickey).start();<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//还是用买火车票的例子</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuyTickey</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">int</span> ticketNum = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//定义可重入锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br><br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                System.out.println(ticketNum--);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="synchronized-与Lock-的对比"><a href="#synchronized-与Lock-的对比" class="headerlink" title="synchronized 与Lock 的对比"></a>synchronized 与Lock 的对比</h4><ul><li>Lock是显式锁（手动开启和关闭锁，别忘了关闭锁）synchronized是隐式锁，除了作用域自动释放</li><li>Lock锁只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用Lock锁，JVM将花费更少的时间来调度线程性能更好。并且具有更好的延展性（提供更多的子类）</li><li>优先使用顺序：<ul><li>Lock &gt; 同步代码块（已经进入方法体，分配了相应的资源） &gt; 同步方法（在方法体之外）</li></ul></li></ul><h4 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h4><ul><li>生产者消费者模式</li></ul><h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><ul><li>应用场景：生产者消费者问题<ul><li>假设仓库只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费</li><li>如果仓库里没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止</li><li>仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库里再次放入产品为止</li></ul></li></ul><p><img src="E:\dgut\blog\wjx002\source\images\Thread\线程通信分析.png"></p><ul><li>java提供了几个方法解决线程之间的通信问题</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>wait()</td><td>表示线程一直等待，知道其他线程通知，与sleep不同，会释放锁</td></tr><tr><td>wait(long timeout)</td><td>指定等待的毫秒数</td></tr><tr><td>notify()</td><td>唤醒一个处于等待状态的线程</td></tr><tr><td>notityAll()</td><td>唤醒同一个对象上所有调用wait()方法的线程，优先级高的线程优先调度</td></tr></tbody></table><p><strong>注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常lllegalMonitorStateException</strong></p><h4 id="解决方式1"><a href="#解决方式1" class="headerlink" title="解决方式1"></a>解决方式1</h4><p>并发协作模型“生产者/消费者模式”—&gt;管理法</p><ul><li>生产者：负责生产数据的模型（可能是方法、对象、线程、进程）；</li><li>消费者：负责处理数据的模块（可能是方法、对象、线程、进程）；</li><li>缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区”</li></ul><p><strong>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</strong></p><p><img src="/images/Thread/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png"></p><h4 id="解决方式2"><a href="#解决方式2" class="headerlink" title="解决方式2"></a>解决方式2</h4><ul><li>并发协作模型“生产者/消费者模式”—-&gt;信号灯法</li></ul><p>解决方法一：代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.model.productAndConsumer;<br><br><span class="hljs-comment">//管程法</span><br><span class="hljs-comment">//生产者消费者模型</span><br><br><span class="hljs-keyword">import</span> java.awt.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">process</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        SynContainer synContainer = <span class="hljs-keyword">new</span> SynContainer();<br>        <span class="hljs-keyword">new</span> Product(synContainer).start();<br>        <span class="hljs-keyword">new</span> Consumer(synContainer).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//生产者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-comment">//生产鸡</span><br>    SynContainer synContainer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(SynContainer synContainer)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.synContainer = synContainer;<br>    &#125;<br><br><br>    <span class="hljs-comment">//生产</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;生产了&quot;</span> + i + <span class="hljs-string">&quot;只鸡&quot;</span>);<br>            synContainer.push(<span class="hljs-keyword">new</span> Chicken(i));<br>        &#125;<br>                <br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//消费者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    SynContainer synContainer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(SynContainer synContainer)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.synContainer = synContainer;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;消费了第&quot;</span>+synContainer.pop().id+<span class="hljs-string">&quot;只鸡&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chicken</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chicken</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//缓冲区</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynContainer</span> </span>&#123;<br>    <span class="hljs-comment">//放产品的地方</span><br>    <span class="hljs-comment">//对象数组 指定大小</span><br>    Chicken[] chickens = <span class="hljs-keyword">new</span> Chicken[<span class="hljs-number">10</span>];<br>    <span class="hljs-comment">//统计鸡的数量</span><br>    <span class="hljs-keyword">int</span> account = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//生产者放入产品</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Chicken chicken)</span>  </span>&#123;<br><br>        <span class="hljs-comment">//鸡放满了，只能消费 生产停止</span><br>        <span class="hljs-keyword">if</span> (account &gt;= chickens.length-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//否则就没有满</span><br>        <span class="hljs-comment">//没有满就继续放鸡</span><br>        chickens[account] = chicken;<br>        account++;<br>        <span class="hljs-comment">//通知消费者消费</span><br>        <span class="hljs-keyword">this</span>.notifyAll();<br><br>    &#125;<br><br>    <span class="hljs-comment">//消费者放入产品</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Chicken <span class="hljs-title">pop</span><span class="hljs-params">()</span>  </span>&#123;<br>        <span class="hljs-comment">//如果没有鸡了，消费者停止</span><br>        <span class="hljs-keyword">if</span> (account &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        account--;<br>        Chicken chicken = chickens[account];<br><br>        <span class="hljs-comment">//唤醒生产者</span><br>        <span class="hljs-keyword">this</span>.notifyAll();<br><br>        <span class="hljs-keyword">return</span> chicken;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>解决办法2：信号灯法</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.model.productAndConsumer;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.generic.NEW;<br><br><span class="hljs-comment">//信号灯法</span><br><span class="hljs-comment">//通过一个flag来调度</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Semaphore</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TV tv = <span class="hljs-keyword">new</span> TV();<br>        <span class="hljs-keyword">new</span> Actor(tv).start();<br>        <span class="hljs-keyword">new</span> watch(tv).start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//演员</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    TV tv;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Actor</span><span class="hljs-params">(TV tv)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tv = tv;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br><br>                <span class="hljs-keyword">this</span>.tv.play(<span class="hljs-string">&quot;快乐大本营&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">this</span>.tv.play(<span class="hljs-string">&quot;抖音：记录美好生活&quot;</span>);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//观看者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">watch</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    TV tv;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">watch</span><span class="hljs-params">(TV tv)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tv = tv;<br>    &#125;<br><br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            <span class="hljs-keyword">this</span>.tv.watch();<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电视剧</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TV</span> </span>&#123;<br>    <span class="hljs-comment">//演员表演，观众等待 T</span><br>    <span class="hljs-comment">//观众观看，演员等待F</span><br>    String vedio;<br><br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">//表演</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String vedio)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;演员表演了：&quot;</span> + vedio);<br>        <span class="hljs-comment">//通知观众观看</span><br>        <span class="hljs-keyword">this</span>.notify();<br>        <span class="hljs-keyword">this</span>.vedio = vedio;<br>        <span class="hljs-keyword">this</span>.flag = !<span class="hljs-keyword">this</span>.flag;<br>    &#125;<br><br>    <span class="hljs-comment">//观看</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">watch</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;观众观看了：&quot;</span> + vedio);<br>        <span class="hljs-comment">//通知演员表演</span><br>        <span class="hljs-keyword">this</span>.notifyAll();<br>        <span class="hljs-keyword">this</span>.flag = !<span class="hljs-keyword">this</span>.flag;<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h4><ul><li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</li><li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具。</li><li>好处：<ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理（……）<ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAlivaTime：线程没有任务时最多保持多长时间后会终止</li></ul></li></ul></li></ul><p><img src="/images/Thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.theadpool;<br><br><span class="hljs-comment">//测试线程池</span><br><br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">//1.创建服务，创建线程池</span><br>       <span class="hljs-comment">//Executors.newFixedThreadPool(10)参数是线程池的大小</span><br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br><br>        <span class="hljs-comment">//执行</span><br>        service.execute(<span class="hljs-keyword">new</span> MyThread());<br>        service.execute(<span class="hljs-keyword">new</span> MyThread());<br>        service.execute(<span class="hljs-keyword">new</span> MyThread());<br>        service.execute(<span class="hljs-keyword">new</span> MyThread());<br><br>        <span class="hljs-comment">//关闭连接</span><br>        service.shutdown();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2021/10/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/10/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>在学习Java网络编程之前，我们先来了解什么是计算机网络。</p><p>==计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。==</p><p>那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p><p>对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP/IP协议。</p><p>TCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。</p><blockquote><p>==打电话：连接—接了—-通话         这是TCP协议==</p><p>==发短信： 发就完了——接收         UDP协议==</p></blockquote><h3 id="网络编程的目的："><a href="#网络编程的目的：" class="headerlink" title="网络编程的目的："></a>网络编程的目的：</h3><p>无线电台….传播交流信息，数据交换，通信</p><h3 id="想要达到这个效果需要什么："><a href="#想要达到这个效果需要什么：" class="headerlink" title="想要达到这个效果需要什么："></a>想要达到这个效果需要什么：</h3><ol><li>如何准确的定位到一个网络上的一台主机  192.168.16.124：端口 定位到这个计算机上的某个资源</li><li>找到这个主机，如何传输数据呢？</li></ol><h3 id="网络通信的要素"><a href="#网络通信的要素" class="headerlink" title="网络通信的要素"></a>网络通信的要素</h3><p>如何实现网络的通信？</p><p><strong>通信双方地址：</strong></p><ul><li>ip</li><li>端口号</li><li>例子：192.168.16.124:5900</li></ul><p><strong>规则:网络通信的协议</strong></p><ul><li>TCP/IP参考模型：</li></ul><p><img src="/images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png"></p><p>==网络编程是针对传输层的，TCP UDP==</p><ul><li>应用层，提供应用程序之间的通信；</li><li>表示层：处理数据格式，加解密等等；</li><li>会话层：负责建立和维护会话；</li><li>传输层：负责提供端到端的可靠传输；</li><li>网络层：负责根据目标地址选择路由来传输数据；</li><li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li></ul><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ol><li>网络编程中有两个主要问题<ol><li>如何准确定位到网络上的一台或者多台主机     ==ping命令==</li><li>找到主机之后如何进行通信</li></ol></li><li>网络编程中的要输<ol><li>IP和端口号</li><li>网络通信协议  ==UDP   TCP==</li></ol></li></ol><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>java里面有一个inetAddress类</p><p>ip地址：InetAddress</p><ul><li><p>唯一定位一个网络上计算机</p></li><li><p>127.0.0.1    ==本机localhost==</p></li><li><p>ip地址的分类</p><ul><li><p>ipv4/ipv6</p><ul><li>==IPV4==：127.0.0.1 ， 4个字节组成，32位，0~255        2011年就用完了</li><li>==IPV6==：128位，8个无符号整数   16进制</li></ul><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">IPV6形式：刚好八位<br>1111 ；0000：0abc：abcd：123e：1323：0000：0000<br><br>IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似101.202.99.12，<br>而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。<br>IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。<br></code></pre></td></tr></table></figure></li><li><p>公网（互联网） 私网（局域网）</p><ul><li>ABCD类地址==（百度一下）==</li><li>192.168.xx.xx 专门给组织内部使用的（局域网）</li><li>有一个特殊的ip==本机地址==：<code>127.0.0.1</code></li></ul></li><li><p>域名：记忆IP问题（IP太难记了）</p><ul><li>IP: <a href="http://www.vip.com/">www.vip.com</a>   唯品会域名</li></ul></li></ul></li><li><p>网卡</p><ul><li>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</li><li>如果两台计算机位于同一个网络，那么他们之间可以直接通信，==因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的==。</li><li>例子：某台计算机的IP是<code>101.202.99.2</code>，子网掩码是<code>255.255.255.0</code>，那么计算该计算机的网络号是：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">IP = 101.202.99.2<br>Mask = 255.255.255.0<br>Network = IP &amp; Mask = 101.202.99.0<br></code></pre></td></tr></table></figure><ul><li>==网关==<ul><li>如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。</li><li>网关的<strong>作用</strong>：连接多个网络，负责把来自一个网络的数据包发送到另一个网络，这个过程叫做==路由==</li></ul></li></ul></li></ul><p>==<strong>所以一台计算机的一个网卡有3个关键配置：</strong>==</p><ul><li>IP地址，例如：<code>10.0.2.15</code></li><li>子网掩码，例如：<code>255.255.255.0</code></li><li>网关的IP地址，例如：<code>10.0.2.2</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lesson01;<br><br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><br><span class="hljs-comment">//测试IP</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInetAdress</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//查询本机地址</span><br>            InetAddress inetAddress = InetAddress.getByName(<span class="hljs-string">&quot;172.0.0.1&quot;</span>);<br>            System.out.println(inetAddress);<br>            InetAddress inetAddress2 = InetAddress.getByName(<span class="hljs-string">&quot;localhost&quot;</span>);<br>            System.out.println(inetAddress2);<br>            InetAddress inetAddress3 = InetAddress.getLocalHost();<br>            System.out.println(inetAddress3);<br><br>            <span class="hljs-comment">//查询网站ip地址</span><br>            InetAddress inetAddress1 = InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>);<br>            System.out.println(inetAddress1);<br><br>            <span class="hljs-comment">//常用方法</span><br>            System.out.println(inetAddress1.getAddress());<br>            System.out.println(inetAddress1.getCanonicalHostName());<br>            System.out.println(inetAddress1.getHostAddress());<br>            System.out.println(inetAddress1.getHostName());<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口表示计算机的一个程序的进程；</p><ul><li><p>不同的进程有不同的端口号！ 用来区分软件！</p></li><li><p>被规定0~65535</p></li><li><p>TCP，UDP端口数：65535*2</p><ul><li>如果tcp用了80   udp也可以用80</li><li>单个协议下，端口号不可以冲突  就是tcp不能有多个80</li></ul></li><li><p>端口分类</p><ul><li>公有端口 0~1023<ul><li>HTTP：80</li><li>HTTPS：443</li><li>FTP：21</li><li>Telent：23</li></ul></li><li>程序注册端口：1024 - 49151，分配给用户<ul><li>Tomcat：8080</li><li>MySQL：3306</li><li>Oracle：1521</li></ul></li><li>动态、私有：49152~65535</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看所有端口</span><br>netstat -ano<br>netstat -ano|findstr <span class="hljs-string">&quot;5900&quot;</span><br><br></code></pre></td></tr></table></figure></li></ul><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>协议：相当于约定，就好比我们一般讲话对什么人用什么话</p><p><strong>网络通信协议</strong>：速率，传输码率，代码结构，传输控制….</p><p><strong>问题</strong>：非常的复杂？</p><p>大事化小：分层！</p><p><strong>TCP/IP协议簇</strong>：实际是是一组协议</p><p>重要：</p><ul><li>TCP：用户传输控制协议</li><li>UDP：用户数据报协议</li></ul><p>比较出名的协议：</p><ul><li>TCP：</li><li>IP：网络互连协议</li></ul><h4 id="TCP-UDP对比"><a href="#TCP-UDP对比" class="headerlink" title="TCP  UDP对比"></a>TCP  UDP对比</h4><p><strong>TCP：类似打电话</strong></p><ul><li><p>连接、稳定</p></li><li><p>三次握手、四次挥手</p><blockquote><p>==三次握手==</p><p><strong>刚开始客户端处于 closed 的状态，服务端处于 listen 状态</strong>。然后</p><p>1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 **ISN(c)**。此时客户端处于 <strong>SYN_Send</strong> 状态。</p><p>2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p><p>3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p><p>4、服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了链接。</p></blockquote><blockquote><p><strong>这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以</strong>：<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p></blockquote><blockquote><p>==三次握手的作用==也是有好多的，多记住几个，保证不亏。例如：</p><p>1、==确认双方的接受能力、发送能力是否正常==。</p><p>2、指定自己的初始化序列号，为后面的可靠传送做准备。</p><p>3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到</p></blockquote><blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>四次挥手也一样，千万不要==对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，对方一个 ACK 报文==。然后结束，最好是说的详细一点，例如想下面这样就差不多了，要把每个阶段的<strong>状态</strong>记好，我上次面试就被问了几个了，呵呵。我答错了，还以为自己答对了，当时还解释的头头是道，呵呵。</p><p>刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：</p><p>1、第一次挥手：==客户端==发送一个 ==FIN 报文==，报文中会指定一个序列号。此时客户端处于==<strong>FIN_WAIT1</strong>状态==。</p><p>2、第二次握手：==服务端==收到 FIN 之后，会==发送 ACK 报文==，且把==客户端的序列号值 + 1 作为 ACK 报文的序列号值==，表明已经收到客户端的报文了，此时==服务端处于 <strong>CLOSE_WAIT</strong>状态==。</p><p>3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时==服务端处于 <strong>LAST_ACK</strong> 的状态==。</p><p>4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p><p>5、服务端收到 ACK 报文之后，就处于关闭连接了，==处于 CLOSED 状态==。</p></blockquote></li><li><p>客户端、服务端</p></li><li><p>传输完成、释放连接、效率低</p></li></ul><p><strong>UDP：类似发短信</strong></p><ul><li>不连接、不稳定</li><li>客户端、服务端：没有明确的界限</li><li>不管你有没有准备好，都可以发过去</li><li>应用例子：DDOC：洪水攻击（饱和攻击）</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>在开发网络应用程序的时候，我们又会遇到Socket这个概念。Socket是一个抽象概念，<strong>一个应用程序通过一个Socket来建立一个远程连接</strong>，而<strong>Socket内部通过TCP/IP协议把数据传输到网络：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───────────┐                                   ┌───────────┐<br>│Application│                                   │Application│<br>├───────────┤                                   ├───────────┤<br>│  Socket   │                                   │  Socket   │<br>├───────────┤                                   ├───────────┤<br>│    TCP    │                                   │    TCP    │<br>├───────────┤      ┌──────┐       ┌──────┐      ├───────────┤<br>│    IP     │&lt;────&gt;│Router│&lt;─────&gt;│Router│&lt;────&gt;│    IP     │<br>└───────────┘      └──────┘       └──────┘      └───────────┘<br></code></pre></td></tr></table></figure><p>Socket、TCP和部分IP的功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单的封装。例如，Java提供的几个Socket相关的类就封装了操作系统提供的接口。</p><hr><p>==为什么需要Socket进行网络通信？==</p><p>因为仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。</p><hr><p>一个Socket就是由==IP地址和端口号==（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<em><strong>特权端口</strong></em>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p><p>==使用Socket进行网络编程时，本质上就是两个进程之间的网络通信==。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p><p>因此，当Socket连接成功地在服务器端和客户端之间建立后：</p><ul><li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li><li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li></ul><h4 id="Socket流"><a href="#Socket流" class="headerlink" title="Socket流"></a>Socket流</h4><p>当Socket连接创建成功后，无论是服务器端，还是客户端，我们都使用<code>Socket</code>实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用<code>InputStream</code>和<code>OutputStream</code>来封装Socket的数据流，这样我们使用Socket的流，和普通IO流类似：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 用于读取网络数据:<br>InputStream <span class="hljs-keyword">in</span> = sock.getInputStream();<br><span class="hljs-regexp">//</span> 用于写入网络数据:<br>OutputStream out = sock.getOutputStream();<br></code></pre></td></tr></table></figure><p>最后我们重点来看看，为什么写入网络数据时，要调用<code>flush()</code>方法。</p><p>如果不调用<code>flush()</code>，我们很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是我们以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而我们又想强制把这些数据发送到网络，就必须调用<code>flush()</code>强制把缓冲区数据发送出去。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>使用Java进行TCP编程时，需要使用Socket模型：</p><ul><li>服务器端用<code>ServerSocket</code>监听指定端口；</li><li>客户端使用<code>Socket(InetAddress, port)</code>连接服务器；</li><li>服务器端用<code>accept()</code>接收连接并返回<code>Socket</code>；</li><li>双方通过<code>Socket</code>打开<code>InputStream</code>/<code>OutputStream</code>读写数据；</li><li>服务器端通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率；</li><li><code>flush()</code>用于强制输出缓冲区到网络。</li></ul><p>客户端</p><ol><li>连接服务器Socket</li><li>发送消息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lesson02;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCilent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Socket socket = <span class="hljs-keyword">null</span>;<br>        OutputStream os = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">//1.要知道服务器的地址，端口号</span><br>            InetAddress serverIP = InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>            <span class="hljs-keyword">int</span> post = <span class="hljs-number">9999</span>;<br><br>            <span class="hljs-comment">//2.创建一个socket连接</span><br>            socket = <span class="hljs-keyword">new</span> Socket(serverIP, post);<br><br>            <span class="hljs-comment">//3.发生消息   IO流</span><br>            os = socket.getOutputStream();<br>            os.write(<span class="hljs-string">&quot;你好，我就是太阳&quot;</span>.getBytes());<br><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (os!=<span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    os.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (socket != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    socket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>服务器</p><ol><li>建立服务端口ServerSocket、</li><li>等待用户连接 accept</li><li>接收用的消息</li></ol><ul><li>注意到代码<code>serverSocket.accept()</code>表示每当有新的客户端连接进来后，就返回一个<code>Socket</code>实例，这个<code>Socket</code>实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的<code>Socket</code>创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。</li><li>如果没有客户端连接进来，<code>accept()</code>方法会阻塞并一直等待。如果有多个客户端同时连接进来，<code>ServerSocket</code>会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用<code>accept()</code>就可以获取新的连接。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lesson02;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-comment">//服务器端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">null</span>;<br>        Socket socket = <span class="hljs-keyword">null</span>;<br>        InputStream is = <span class="hljs-keyword">null</span>;<br>        ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.我有一个地址</span><br>            serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9999</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">//2.等待客户端连接过来</span><br>                socket = serverSocket.accept();<br>                <span class="hljs-comment">//读取客户端的消息</span><br>                is = socket.getInputStream();<br><br>                <span class="hljs-comment">//管道流</span><br>                byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>                <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-keyword">int</span> len;<br>                <span class="hljs-keyword">while</span> ((len = is.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>                    byteArrayOutputStream.write(buffer,<span class="hljs-number">0</span>,len);<br>                &#125;<br>                System.out.println(byteArrayOutputStream.toString());<br>            &#125;<br><br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (byteArrayOutputStream!=<span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    byteArrayOutputStream.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (is!=<span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    is.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (socket!=<span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    socket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (serverSocket!=<span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    serverSocket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lesson03;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//创建端口</span><br>        Socket socket = <span class="hljs-keyword">new</span> Socket(InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>), <span class="hljs-number">9000</span>);<br>        <span class="hljs-comment">//创建输出流</span><br>        OutputStream os = socket.getOutputStream();<br><br>        <span class="hljs-comment">//读取文件</span><br>         FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;123.jpg&quot;</span>));<br><br>        <span class="hljs-comment">//写出文件 让服务端接收</span><br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = fileInputStream.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            os.write(buffer, <span class="hljs-number">0</span>, len);<br>        &#125;<br><br>        <span class="hljs-comment">//告诉服务端发送完毕</span><br>        socket.shutdownOutput();<span class="hljs-comment">//输出完毕</span><br><br>        <span class="hljs-comment">//接收完毕</span><br>        InputStream inputStream = socket.getInputStream();<br><br>        <span class="hljs-comment">//String byte[]</span><br>        ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        <span class="hljs-keyword">byte</span>[] buffer2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len2;<br><br>        <span class="hljs-keyword">while</span> ((len2 = inputStream.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            baos.write(buffer,<span class="hljs-number">0</span>,len2);<br>        &#125;<br>        System.out.println(baos.toString());<br><br>        <span class="hljs-comment">//关闭资源</span><br>        baos.close();<br>        inputStream.close();<br>        fileInputStream.close();<br>        os.close();<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lesson03;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建服务</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9000</span>);<br><br>        <span class="hljs-comment">//监听器</span><br>        Socket socket = serverSocket.accept();<br><br>        <span class="hljs-comment">//获取输入流</span><br>        InputStream inputStream = socket.getInputStream();<br><br>        <span class="hljs-comment">//文件输出</span><br>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;456.jpg&quot;</span>));<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = inputStream.read()) != -<span class="hljs-number">1</span>) &#123;<br>            fileOutputStream.write(buffer, <span class="hljs-number">0</span>, len);<br>        &#125;<br><br>        <span class="hljs-comment">//通知客户端我接收完毕</span><br>        OutputStream outputStream = socket.getOutputStream();<br>        outputStream.write(<span class="hljs-string">&quot;我接收完了，你可以断开了&quot;</span>.getBytes());<br><br><span class="hljs-comment">//        关闭资源</span><br>        outputStream.close();<br>        fileOutputStream.close();<br>        inputStream.close();<br>        socket.close();<br>        serverSocket.close();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><blockquote><p>不用连接 不稳定</p></blockquote><p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。</p><p>在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p><p>服务器端：</p><p>在服务器端，使用UDP也需要监听指定的端口。Java提供了<code>DatagramSocket</code>来实现这个功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">6666</span>); <span class="hljs-comment">// 监听指定端口</span><br><span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 无限循环</span><br>    <span class="hljs-comment">// 数据缓冲区:</span><br>    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>    DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(buffer, buffer.length);<br>    ds.receive(packet); <span class="hljs-comment">// 收取一个UDP数据包</span><br>    <span class="hljs-comment">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度</span><br>    <span class="hljs-comment">// 将其按UTF-8编码转换为String:</span><br>    String s = <span class="hljs-keyword">new</span> String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);<br>    <span class="hljs-comment">// 发送数据:</span><br>    <span class="hljs-keyword">byte</span>[] data = <span class="hljs-string">&quot;ACK&quot;</span>.getBytes(StandardCharsets.UTF_8);<br>    packet.setData(data);<br>    ds.send(packet);<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器端首先使用如下语句在指定的端口监听UDP数据包：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">DatagramSocket ds</span> = new DatagramSocket(6666);<br></code></pre></td></tr></table></figure><p>如果没有其他应用程序占据这个端口，那么监听成功，我们就使用一个无限循环来处理收到的UDP数据包：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (<span class="hljs-comment">;;) &#123;</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>要接收一个UDP数据包，需要准备一个<code>byte[]</code>缓冲区，并通过<code>DatagramPacket</code>实现接收：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">byte</span>[] <span class="hljs-built_in">buffer</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(<span class="hljs-built_in">buffer</span>, <span class="hljs-built_in">buffer</span>.length);<br>ds.receive(packet);<br></code></pre></td></tr></table></figure><p>假设我们收取到的是一个<code>String</code>，那么，通过<code>DatagramPacket</code>返回的<code>packet.getOffset()</code>和<code>packet.getLength()</code>确定数据在缓冲区的起止位置：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">packet</span>.<span class="hljs-params">getData</span>()</span>, packet.get<span class="hljs-constructor">Offset()</span>, packet.get<span class="hljs-constructor">Length()</span>, StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure><p>当服务器收到一个DatagramPacket后，通常必须立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。</p><p>发送UDP包也是通过<code>DatagramPacket</code>实现的，发送代码非常简单：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">byte</span>[] <span class="hljs-class"><span class="hljs-keyword">data</span> = ...</span><br><span class="hljs-title">packet</span>.setData(<span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br><span class="hljs-title">ds</span>.send(packet);<br></code></pre></td></tr></table></figure><hr><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>和服务器端相比，客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">DatagramSocket ds = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DatagramSocket()</span>;<br>ds.set<span class="hljs-constructor">SoTimeout(1000)</span>;<br>ds.connect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">InetAddress</span>.</span></span>get<span class="hljs-constructor">ByName(<span class="hljs-string">&quot;localhost&quot;</span>)</span>, <span class="hljs-number">6666</span>); <span class="hljs-comment">// 连接指定服务器和端口</span><br><span class="hljs-comment">// 发送:</span><br>byte<span class="hljs-literal">[]</span> data = <span class="hljs-string">&quot;Hello&quot;</span>.get<span class="hljs-constructor">Bytes()</span>;<br>DatagramPacket packet = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DatagramPacket(<span class="hljs-params">data</span>, <span class="hljs-params">data</span>.<span class="hljs-params">length</span>)</span>;<br>ds.send(packet);<br><span class="hljs-comment">// 接收:</span><br>byte<span class="hljs-literal">[]</span> buffer = <span class="hljs-keyword">new</span> byte<span class="hljs-literal">[<span class="hljs-number">1024</span>]</span>;<br>packet = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DatagramPacket(<span class="hljs-params">buffer</span>, <span class="hljs-params">buffer</span>.<span class="hljs-params">length</span>)</span>;<br>ds.receive(packet);<br>String resp = <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">packet</span>.<span class="hljs-params">getData</span>()</span>, packet.get<span class="hljs-constructor">Offset()</span>, packet.get<span class="hljs-constructor">Length()</span>);<br>ds.disconnect<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p>客户端打开一个<code>DatagramSocket</code>使用以下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">DatagramSocket ds = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DatagramSocket()</span>;<br>ds.set<span class="hljs-constructor">SoTimeout(1000)</span>;<br>ds.connect(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">InetAddress</span>.</span></span>get<span class="hljs-constructor">ByName(<span class="hljs-string">&quot;localhost&quot;</span>)</span>, <span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure><p>客户端创建<code>DatagramSocket</code>实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用<code>setSoTimeout(1000)</code>设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。</p><p>注意到客户端的<code>DatagramSocket</code>还调用了一个<code>connect()</code>方法“连接”到指定的服务器端。不是说UDP是无连接的协议吗？为啥这里需要<code>connect()</code>？</p><p>这个<code>connect()</code>方法不是真连接，它是为了在客户端的<code>DatagramSocket</code>实例中保存服务器端的IP和端口号，确保这个<code>DatagramSocket</code>实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。</p><p>如果客户端希望向两个不同的服务器发送UDP包，那么它必须创建两个<code>DatagramSocket</code>实例。</p><p>后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。</p><p>如果客户端认为通信结束，就可以调用<code>disconnect()</code>断开连接：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ds.disconnect()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>注意到<code>disconnect()</code>也不是真正地断开连接，它只是清除了客户端<code>DatagramSocket</code>实例记录的远程服务器地址和端口号，这样，<code>DatagramSocket</code>实例就可以连接另一个服务器端。</p><h4 id="小结0"><a href="#小结0" class="headerlink" title="小结0"></a>小结0</h4><p>使用UDP协议通信时，服务器和客户端双方无需建立连接：</p><ul><li>服务器端用<code>DatagramSocket(port)</code>监听端口；</li><li>客户端使用<code>DatagramSocket.connect()</code>指定远程地址和端口；</li><li>双方通过<code>receive()</code>和<code>send()</code>读写数据；</li><li><code>DatagramSocket</code>没有IO流接口，数据被直接写入<code>byte[]</code>缓冲区</li></ul><hr><p>发送端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lesson04;<br><br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-comment">//发送端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//1.建立一个socket</span><br>        DatagramSocket datagramSocket = <span class="hljs-keyword">new</span> DatagramSocket();<br><br>        <span class="hljs-comment">//建一个包</span><br>        String msg = <span class="hljs-string">&quot;你好服务端&quot;</span>;<br>            <span class="hljs-comment">//发送给谁</span><br>        InetAddress localhost = InetAddress.getByName(<span class="hljs-string">&quot;localhost&quot;</span>);<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">9999</span>;<br>        DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(msg.getBytes(),<span class="hljs-number">0</span>,msg.getBytes().length,localhost,port);<br><br>        <span class="hljs-comment">//发送包</span><br>        datagramSocket.send(packet);<br><br>        <span class="hljs-comment">//关闭流</span><br>        datagramSocket.close();<br><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lesson04;<br><br><span class="hljs-keyword">import</span> java.net.DatagramPacket;<br><span class="hljs-keyword">import</span> java.net.DatagramSocket;<br><span class="hljs-keyword">import</span> java.net.SocketException;<br><br><span class="hljs-comment">//接收端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//开放端口</span><br>        DatagramSocket datagramSocket = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">9999</span>);<br><br><br><br>        <span class="hljs-comment">//接收数据</span><br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        DatagramPacket datagramPacket = <span class="hljs-keyword">new</span> DatagramPacket(buffer, <span class="hljs-number">0</span>, buffer.length);<br><br>        <span class="hljs-comment">//最终接收</span><br>        datagramSocket.receive(datagramPacket);<br>        System.out.println(datagramPacket.getAddress().getHostAddress());<br>        System.out.println(<span class="hljs-keyword">new</span> String(datagramPacket.getData()));<br><br>        <span class="hljs-comment">//关闭流</span><br>        datagramSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="循环发送"><a href="#循环发送" class="headerlink" title="循环发送"></a>循环发送</h4><p>==发送==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.chat;<br><br><span class="hljs-keyword">import</span> java.io.BufferedInputStream;<br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-comment">//发送</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sender</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//建立socket</span><br>        DatagramSocket datagramSocket = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">8888</span>);<br><br>        <span class="hljs-comment">//数据 控制台输入</span><br>        <span class="hljs-comment">//控制台输入</span><br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            String data = reader.readLine();<br>            <span class="hljs-keyword">byte</span>[] datas = data.getBytes();<br><br>            DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(datas, <span class="hljs-number">0</span>, datas.length, <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>));<br>            <span class="hljs-comment">//发送包</span><br>            datagramSocket.send(packet);<br><br>            <span class="hljs-keyword">if</span> (data.equals(<span class="hljs-string">&quot;bye&quot;</span>)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//关闭流</span><br>        datagramSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>==接收==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.chat;<br><br><span class="hljs-keyword">import</span> java.net.DatagramPacket;<br><span class="hljs-keyword">import</span> java.net.DatagramSocket;<br><span class="hljs-keyword">import</span> java.net.SocketException;<br><span class="hljs-keyword">import</span> java.text.BreakIterator;<br><br><span class="hljs-comment">//接收</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receive</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//端口</span><br>        DatagramSocket datagramSocket = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">6666</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br>            <span class="hljs-comment">//接收数据</span><br><br>            <span class="hljs-keyword">byte</span>[] contains = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br><br><br>            DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(contains, <span class="hljs-number">0</span>, contains.length);<br><br><br>            datagramSocket.receive(packet);<br>            <span class="hljs-keyword">byte</span>[] data = packet.getData();<br>            String recieiceDate = <span class="hljs-keyword">new</span> String(data, <span class="hljs-number">0</span>, data.length);<br>            System.out.println(recieiceDate);<br><br>            <span class="hljs-keyword">if</span> (recieiceDate.equals(<span class="hljs-string">&quot;bye&quot;</span>)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//关闭流</span><br>        datagramSocket.close();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="多线程交流"><a href="#多线程交流" class="headerlink" title="多线程交流"></a>多线程交流</h4><p>TalkSend.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.chat02;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.net.DatagramPacket;<br><span class="hljs-keyword">import</span> java.net.DatagramSocket;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TalkSend</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    DatagramSocket datagramSocket = <span class="hljs-keyword">null</span>;<br>    BufferedReader reader = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> MyPort;<br>    <span class="hljs-keyword">private</span> String MyAddress;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ToPort;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TalkSend</span><span class="hljs-params">(<span class="hljs-keyword">int</span> myPort, String myAddress, <span class="hljs-keyword">int</span> toPort)</span> </span>&#123;<br>        MyPort = myPort;<br>        MyAddress = myAddress;<br>        ToPort = toPort;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//建立socket</span><br>            datagramSocket = <span class="hljs-keyword">new</span> DatagramSocket(MyPort);<br><br>            <span class="hljs-comment">//数据 控制台输入</span><br>            <span class="hljs-comment">//控制台输入</span><br>            reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                String data = reader.readLine();<br>                <span class="hljs-keyword">byte</span>[] datas = data.getBytes();<br><br>                DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(datas, <span class="hljs-number">0</span>, datas.length, <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-keyword">this</span>.MyAddress, <span class="hljs-keyword">this</span>.ToPort));<br>                <span class="hljs-comment">//发送包</span><br>                datagramSocket.send(packet);<br><br>                <span class="hljs-keyword">if</span> (data.equals(<span class="hljs-string">&quot;bye&quot;</span>)) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//关闭流</span><br>        datagramSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TalkReceive.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.chat02;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.DatagramPacket;<br><span class="hljs-keyword">import</span> java.net.DatagramSocket;<br><span class="hljs-keyword">import</span> java.net.SocketException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TalkReceive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    DatagramSocket datagramSocket = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TalkReceive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-comment">//端口</span><br>            datagramSocket = <span class="hljs-keyword">new</span> DatagramSocket(port);<br>        &#125; <span class="hljs-keyword">catch</span> (SocketException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//接收数据</span><br><br>                <span class="hljs-keyword">byte</span>[] contains = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br><br><br>                DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(contains, <span class="hljs-number">0</span>, contains.length);<br><br><br>                datagramSocket.receive(packet);<br>                <span class="hljs-keyword">byte</span>[] data = packet.getData();<br>                String recieiceDate = <span class="hljs-keyword">new</span> String(data, <span class="hljs-number">0</span>, data.length);<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span> +recieiceDate);<br><br>                <span class="hljs-keyword">if</span> (recieiceDate.equals(<span class="hljs-string">&quot;bye&quot;</span>)) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//关闭流</span><br>        datagramSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TalkStudent.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.chat02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TalkStudent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TalkSend(<span class="hljs-number">6666</span>,<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">8888</span>),<span class="hljs-string">&quot;学生&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TalkReceive(<span class="hljs-number">9999</span>),<span class="hljs-string">&quot;老师&quot;</span>).start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TalkTeacher.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.chat02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TalkTeacher</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TalkSend(<span class="hljs-number">5555</span>,<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">9999</span>),<span class="hljs-string">&quot;老师&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TalkReceive(<span class="hljs-number">8888</span>),<span class="hljs-string">&quot;学生&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>==可以互相发信息==</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><blockquote><p>统一资源定义符：定位互联网上的某个资源</p><p>DNS域名解析</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">协议：<span class="hljs-regexp">//i</span>p地址：端口<span class="hljs-regexp">/项目名/</span>资源<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.lesson05;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.net.HttpURLConnection;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">URLDown</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//下载地址</span><br>        URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;https://m801.music.126.net/20210416005842/26a440ddd8500c5f41152bd182be33b2/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/8366666591/cac9/d94d/8948/e2b3eea69209862623657b08bb7d6d19.m4a&quot;</span>);<br><br>        <span class="hljs-comment">//连接这个资源 HTTP</span><br>        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();<br><br>        InputStream inputStream = urlConnection.getInputStream();<br><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;1.m4a&quot;</span>));<br><br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            fos.write(buffer,<span class="hljs-number">0</span>,len);<br><br>        &#125;<br>        fos.close();<br>        inputStream.close();<br>        urlConnection.disconnect();<span class="hljs-comment">//断开连接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2021/10/04/%E5%BC%82%E5%B8%B8/"/>
    <url>/2021/10/04/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="D:\study\typora\截图\异常目录.png"></p><h3 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h3><ul><li>异常指程序运行中出现的不期而遇的各种状况，如文件找不到，网络连接失败，非法参数</li><li>异常发生在程序运行期间，他影响了正常运行</li></ul><h3 id="简单分类"><a href="#简单分类" class="headerlink" title="简单分类"></a>简单分类</h3><ul><li>检测性异常</li><li>运行时异常</li><li>错误ERROR</li></ul><h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3><ul><li>java把异常当做对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类</li><li>在java API中已经定义了许多异常类，这些异常类分为两大类，错误ERROR和异常Exception</li></ul><p><img src="D:\study\typora\截图\异常结构.png"></p><h3 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h3><ul><li>Error类对象有java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关</li><li>java虚拟机运行错误，当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError.这些异常发生时，Java虚拟机（JVm）一般会选择线程终止</li><li>还有发生在虚拟机试图执行应用时，如类定义错误，连接错误，这些错误是不可查的，绝大多是是不允许发生的</li></ul><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p><img src="D:\study\typora\截图\Exception.png"></p><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><ul><li><p>抛出异常</p></li><li><p>捕获异常</p></li><li><p>异常处理的五个关键字</p><ul><li>try</li><li>catch</li><li>finally</li><li>throw</li><li>throws</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.exception;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br><br>        <br><br>        <span class="hljs-comment">//finally可以不要，假设IO资源 就可以放在finally来关闭</span><br>        <br>        <br>        <span class="hljs-comment">//快捷键  Ctrl + Alt + T</span><br>    &#125;<br><br>    <span class="hljs-comment">//假设这个方法中，没办法处理这个异常，方法向上抛出异常</span><br>    <span class="hljs-comment">//用throws</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> ArithmeticException</span>&#123;<br>        <span class="hljs-comment">//假设要去捕获多个异常，要从小到大</span><br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//监控区域</span><br>            <span class="hljs-comment">//System.out.println(a / b);</span><br><span class="hljs-comment">//            new Test().a();</span><br><br>            <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException();<span class="hljs-comment">//主动抛出异常  一般在方法中使用</span><br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<span class="hljs-comment">//捕获异常</span><br>            <span class="hljs-comment">//System.out.println(&quot;程序出现异常，变量b不可以为0&quot;);</span><br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//处理善后工作，一定会执行</span><br>            System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        b();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        a();<br>    &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p><img src="D:\study\typora\截图\自定义异常.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.exception.demo02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>    <span class="hljs-comment">//传递数字》10</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> detail;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span><span class="hljs-params">(<span class="hljs-keyword">int</span> detail)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.detail = detail;<br>    &#125;<br><br>    <span class="hljs-comment">//异常的打印信息：toString</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyException&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;detail=&quot;</span> + detail +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">package</span> com.exception.demo02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> <span class="hljs-keyword">throws</span> MyException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;传递的参数为：&quot;</span>+a);<br>        <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException(a);<span class="hljs-comment">//paochu</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            test(<span class="hljs-number">11</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (MyException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;MyException==&gt;&quot;</span> + e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="D:\study\typora\截图\经验总结.png"></p>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内部类</title>
    <link href="/2021/10/03/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2021/10/03/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2021/03/29 星期一</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">out</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这是外部类的方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;这是内部类的方法&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//获得外部类的私有属性</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(id);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br>Outer outer = <span class="hljs-keyword">new</span> Outer();<br>        <span class="hljs-comment">//通过这个外部类来实例化内部类</span><br>        Outer.Inner inner = outer.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;<br>        inner.getId();<br><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><p><img src="D:\study\typora\截图\内部类.png">   </p>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象类和接口</title>
    <link href="/2021/10/02/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/10/02/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2021 /03/29 星期一</p></blockquote><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><img src="D:\study\typora\截图\抽象类.png"></p><ul><li><p>```<br>//抽象类的所有方法，继承它的子类，必须实现它的所有方法，</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><br>- ```<br>  /抽象类 <span class="hljs-keyword">abstract</span> 类 <span class="hljs-keyword">extends</span> ：单继承   没有多继承<br>  <span class="hljs-comment">//但是  接口 可以多继承</span><br></code></pre></td></tr></table></figure></li><li><p>```<br>//1.不能new这个抽象类，只能靠子类去实现它；约束！<br>//2.抽象类里面可以写普通的方法<br>//3.抽象方法只能写在抽象类中<br>//抽象的抽象：约束</p><p>//思考题？<br>//抽象类不能new对象，抽象类还有构造器吗   **有构造器<br>//抽象类存在的意义    **提高开发效率，减少代码，提取共同方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>```java<br><span class="hljs-comment">//抽象类 abstract 类 extends ：单继承   没有多继承</span><br><span class="hljs-comment">//但是  接口 可以多继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span> </span>&#123;<br><br>    <span class="hljs-comment">//约束~有人帮我们实现</span><br>    <span class="hljs-comment">//astract 抽象方法，只有名字，没有方法的实现！</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//1.不能new这个抽象类，只能靠子类去实现它；约束！</span><br>    <span class="hljs-comment">//2.抽象类里面可以写普通的方法</span><br>    <span class="hljs-comment">//3.抽象方法只能写在抽象类中</span><br>    <span class="hljs-comment">//抽象的抽象：约束</span><br><br>    <span class="hljs-comment">//思考题？</span><br>    <span class="hljs-comment">//抽象类不能new对象，抽象类还有构造器吗   **有构造器</span><br>    <span class="hljs-comment">//抽象类存在的意义    **提高开发效率，减少代码，提取共同方法，</span><br>&#125;<br><br><br><span class="hljs-comment">//抽象类的所有方法，继承它的子类，必须实现它的所有方法，（</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Action</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><img src="D:\study\typora\截图\接口.png"></p><ul><li><p>接口的本质是契约</p></li><li><p>```<br>接口作用：</p><pre><code>1.约束2.定义一些方法，让不同的人实现3.public abstract  方法4.public static final 常量5.接口不能被实例化，接口中没有构造方法6.implements 可以实现多个接口7.必须重写接口的所有方法</code></pre><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>- ```<br>  <span class="hljs-regexp">//</span>抽象类是：extends<br>  <span class="hljs-regexp">//</span>类可以实现接口，implements 接口<br>  <span class="hljs-regexp">//</span>实现了接口了，就必须重写接口的所有方法<br>  <br>  <span class="hljs-regexp">//</span>多继承   ~利用接口实现多继承<br></code></pre></td></tr></table></figure></li><li><p>```<br>//接口中的所有定义的方法其实都是抽象的 public abstract<br>//接口都需有有一个实现类</p><p>//常量：接口里面定义的都是常量<br>//public static final</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>```java<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TimeService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">time</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-comment">//接口中的所有定义的方法其实都是抽象的 public abstract</span><br>    <span class="hljs-comment">//接口都需有有一个实现类</span><br><br>    <span class="hljs-comment">//常量：接口里面定义的都是常量</span><br>    <span class="hljs-comment">//public static final</span><br>    <span class="hljs-keyword">int</span> AGE = <span class="hljs-number">99</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String naem)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br><br><br><br><span class="hljs-comment">//抽象类是：extends</span><br><span class="hljs-comment">//类可以实现接口，implements 接口</span><br><span class="hljs-comment">//实现了接口了，就必须重写接口的所有方法</span><br><br><span class="hljs-comment">//多继承   ~利用接口实现多继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span>,<span class="hljs-title">TimeService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String naem)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">time</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象简单小结类和对象</title>
    <link href="/2021/10/01/%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/10/01/%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="简单小结类和对象"><a href="#简单小结类和对象" class="headerlink" title="简单小结类和对象"></a>简单小结类和对象</h2><blockquote><p>2021/03/23 星期二</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>类与对象<br>     类是一个模板 抽象的，对象是一个具体实例<br><span class="hljs-number">2.</span>方法<br>    定义、调用！<br><span class="hljs-number">3.</span>对象的引用<br>    引用类型        基本类型（<span class="hljs-number">8</span>个）<br>    对象是通过引用来操作的： 栈<span class="hljs-comment">-----&gt;堆</span><br><span class="hljs-number">4.</span>属性：字段field 成员变量<br>    默认初始化：<br>        数字：<span class="hljs-number">0</span>  <span class="hljs-number">0.0</span><br>        <span class="hljs-type">char</span>：u0000<br>        <span class="hljs-type">boolean</span>：<span class="hljs-keyword">false</span><br>        引用：<span class="hljs-keyword">null</span><br>    修饰符  属性类型  属性名 = 属性值;<br><span class="hljs-number">5.</span>对象的创建和使用：<br>    <span class="hljs-number">1.</span>必须使用<span class="hljs-built_in">new</span>关键字创建对象，构造器  Person 家旭 = <span class="hljs-built_in">new</span> Person();<br>    <span class="hljs-number">2.</span>对象的属性：家旭.name<br>    <span class="hljs-number">3.</span>对象的方法：家旭.sleep();<br><br><span class="hljs-number">6.</span>类：<br>    静态的属性   属性<br>    动态的行为   方法<br><br>    三大特性：封装、继承、多态<br></code></pre></td></tr></table></figure><h2 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h2><p><img src="D:\study\typora\截图\封装.png"></p><p><strong>高内聚低耦合</strong></p><ul><li>高内聚：类的内部数据操作细节自己完成，不允许外包部干涩</li><li>低耦合：仅暴露少量方法给外部使用</li></ul><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><ul><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现细节</li><li>统一接口</li><li>系统可维护性增加了</li></ul><hr><h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h2><p><img src="D:\study\typora\截图\继承.png"></p><ul><li><strong>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模</strong></li><li>子类是父类的拓展</li><li><strong>java只有单继承，没有多继承</strong></li><li>继承是类与类之间的一个关系，除此之外关系还有<strong>依赖、组合、聚合等</strong></li></ul><hr><p><strong>快捷键</strong></p><p>Ctrl + h  查看继承树</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">在java中，所有的类，都默认直接间接继承<span class="hljs-keyword">object</span><br>子类继承父类，就会继承父类的所有方法<br></code></pre></td></tr></table></figure><hr><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>this关键字：当前类的</p><p>super关键字：父类的  //不可以直接调用私有的属性方法</p><p>先调用父类的构造器，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>super注意点：</strong></p><ul><li>super调用父类的构造方法，必须在构造方法的第一个</li><li>super必须只能出现在子类的方法或者构造方法中</li><li>super和this不能同时调用构造方法</li></ul><p><strong>VS this</strong></p><ul><li>代表对象不同<ul><li>this：本身调用者这个对象</li><li>super代表父类对象的引用</li></ul></li><li>前提<ul><li>this：没有继承也可以使用</li><li>super：只能在继承条件下才可以使用</li></ul></li><li>构造方法<ul><li>this()：本类的构造</li><li>super()：父类的构造</li></ul></li></ul><hr><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">重写：需要有继承关系，子类重写父类的方法！<br>    <span class="hljs-number">1.</span>方法名必须相同<br>    <span class="hljs-number">2.</span>参数列表列表必须相同<br>    <span class="hljs-number">3.</span>修饰符：范围可以扩大，但不能缩小     <span class="hljs-keyword">public</span>  <span class="hljs-keyword">protected</span>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">private</span><br>    <span class="hljs-number">4.</span>抛出的异常，范围可以被缩小但不能被扩大； classNotFountException---&gt;Exception(大)<br><br><br>重写：子类的方法必须和父类一致，但是方法提不同<br><br>为什么需要重写：<br>    <span class="hljs-number">1.</span>父类的功能子类不一定需要，或者不一定满足！<br>    ALt + Insert  ：<span class="hljs-keyword">override</span> 重写<br></code></pre></td></tr></table></figure><p>注意点：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>静态方法：方法的调用只和左边，定义的数据类型有关<br><span class="hljs-regexp">//</span>非静态方法：才可以重写，重写只能重写public<br><span class="hljs-regexp">//</span>重写只存在于父子继承中<br>静态的方法和非静态的方法区别很大<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重写都是方法的重写，与属性无关</span><br><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B==&gt;test()&quot;</span>);<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//子类</span><br><span class="hljs-comment">//继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A===&gt;test()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//方法的调用</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//静态方法：方法的调用只和左边，定义的数据类型有关</span><br>        <span class="hljs-comment">//非静态方法：才可以重写，重写只能重写public</span><br>        <span class="hljs-comment">//重写只存在于父子继承中</span><br>        A a = <span class="hljs-keyword">new</span> A();<br>        a.test();<br>        <span class="hljs-comment">//父类的引用指向了子类</span><br>        B b = <span class="hljs-keyword">new</span> A();<br>        b.test();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>上面两个方法都是静态方法</strong></p><p><img src="D:\study\typora\截图\静态方法重写.png"></p><hr><ul><li>结果b还是调用了父类的方法</li><li>所以说：静态方法：方法的调用只和左边，定义的数据类型有关</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重写都是方法的重写，与属性无关</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B==&gt;test()&quot;</span>);<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A===&gt;test()&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//方法的调用</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//静态方法：方法的调用只和左边，定义的数据类型有关</span><br>        <span class="hljs-comment">//非静态方法：才可以重写，重写只能重写public</span><br>        <span class="hljs-comment">//重写只存在于父子继承中</span><br>        A a = <span class="hljs-keyword">new</span> A();<br>        a.test();<br>        <span class="hljs-comment">//父类的引用指向了子类</span><br>        B b = <span class="hljs-keyword">new</span> A();<br>        b.test();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>将上述两个方法改为非静态方法</strong></p><p><img src="D:\study\typora\截图\非静态方法.png"></p><hr><ul><li>发现输出和上面不一样了</li><li>这就说明 静态的方法属于类，非静态的方法属于对象</li><li>子类重写了方法和非静态方法有关，和静态方法关系不大</li><li>子类重写父类的方法不能是private，否则不算是重写</li></ul><p><strong>重写都是方法的重写，与属性无关</strong></p><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><img src="D:\study\typora\截图\多态.png"></p><p>多态是方法的多态，属性没有多态    </p><ul><li>当父类new一个子类对象时<ul><li>调用自己的有而子类没有的方法 是    可以的</li><li>子类重写了父类的方法，优先执行子类的方法</li><li>子类有，而父类没有，则只能进行类型转换，否则无法调用<ul><li>即Student 能调用的方法都是自己的或者继承父类的</li><li>Person是父类型，可以指向子类，但是不能调用子类独有的方法</li></ul></li><li>对象能执行什么方法，主要看对象左边的类型，和右边关系不大</li></ul></li></ul><hr><p><strong>多态的注意事项</strong></p><ul><li>多态是方法的多态，属性没有多态</li><li>父类和子类，有联系，类型转换异常！ ClassCastExcetion!</li><li>在运行中才可以确定的</li><li>存在条件：<ul><li>继承条件</li><li>方法需要重写</li><li>父类引用指向子类对象    Father father = new Son();<ul><li>方法不可以重写：<ul><li>static方法：属于类，不属于实例</li><li>final 常量</li><li>private 私有的</li></ul></li></ul></li></ul></li></ul><hr><h4 id="instance-of"><a href="#instance-of" class="headerlink" title="instance of"></a>instance of</h4><ul><li>instanceof  判断两个类是否存在父子关系，是则true，否这false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//object&gt;string</span><br>        <span class="hljs-comment">//object&gt;person&gt;teacher</span><br>        <span class="hljs-comment">//object&gt;person&gt;student</span><br>        <span class="hljs-comment">//</span><br>        Object object = <span class="hljs-keyword">new</span> Student();<br><br>        <span class="hljs-comment">//instanceof  判断两个类是否存在父子关系，是则true，否这false</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//true</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//true</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//true</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Teacher);<span class="hljs-comment">//false</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> String);<span class="hljs-comment">//false</span><br><br>        Person person = <span class="hljs-keyword">new</span> Student();<br><br>        <span class="hljs-comment">//instanceof  判断两个类是否存在父子关系，是则true，否这false</span><br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//true</span><br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//true</span><br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//true</span><br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Teacher);<span class="hljs-comment">//false</span><br>        <span class="hljs-comment">//System.out.println(person instanceof String);//编译报错！</span><br><br>        Student student = <span class="hljs-keyword">new</span> Student();<br><br>        <span class="hljs-comment">//instanceof  判断两个类是否存在父子关系，是则true，否这false</span><br>        System.out.println(student <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//true</span><br>        System.out.println(student <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//true</span><br>        System.out.println(student <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//true</span><br>        <span class="hljs-comment">//System.out.println(student instanceof Teacher);//编译报错</span><br>        <span class="hljs-comment">//System.out.println(person instanceof String);//编译报错！</span><br><br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">X <span class="hljs-keyword">instanceof</span> Y 能不能编译通过，看是否有继承关系<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//类型之间的转化： 父        子</span><br>        <span class="hljs-comment">//高    低</span><br>        Person obj = <span class="hljs-keyword">new</span> Student();<br><br>        <span class="hljs-comment">//student这个对象转换为Student类型，我们就可以使用Student的方法了</span><br><br><span class="hljs-comment">//        Student student = (Student) obj;</span><br>        ((Student) obj).go();<br><br>        <span class="hljs-comment">//子类转换为父类，可能丢失本来自己的一些方法</span><br>        Student student = <span class="hljs-keyword">new</span> Student();<br>        Person person = student;<br><br><br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>父类引用指向子类的对象</li><li>把子类转换为父类，向上转型</li><li>把父类转换为子类，向下转型，强制转换</li><li>方便方法的调用，减少重复的代码！简洁</li></ul><p>抽象：封装，继承，多态！</p><p>抽象类，接口</p><hr><h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><p>private static int age；</p><p>private double score；</p><p>//age 是静态变量</p><p>// score不是静态变量</p><p>所以</p><p>age可以用类直接调用如：Student.age</p><p>score只能用new出来的对象来调用：student.score</p><p>静态方法可以直接调用，</p><p>非静态方法得需用new出来的对象来调用</p><p>非静态方法可以直接调用静态方法</p><p>静态方法不可以直接调用非静态 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    &#123;<br>        <span class="hljs-comment">//匿名代码块</span><br>        System.out.println(<span class="hljs-string">&quot;匿名代码块);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">    static &#123;</span><br><span class="hljs-string">        //静态代码块</span><br><span class="hljs-string">        //永久只执行一次</span><br><span class="hljs-string">        System.out.println(&quot;</span>静态代码块<span class="hljs-string">&quot;);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    public Person()&#123;</span><br><span class="hljs-string">        System.out.println(&quot;</span>构造方法<span class="hljs-string">&quot;);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    public static void main(String[] args) &#123;</span><br><span class="hljs-string">        Person person = new Person();</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">                           </span><br><span class="hljs-string">                           </span><br><span class="hljs-string">                           //静态导入包</span><br><span class="hljs-string">import static java.lang.Math.random;</span><br><span class="hljs-string"></span><br><span class="hljs-string">public class Test &#123;</span><br><span class="hljs-string">    public static void main(String[] args) &#123;</span><br><span class="hljs-string">        System.out.println(random());</span><br><span class="hljs-string">        //如果不加static，则本来的写法是</span><br><span class="hljs-string">        System.out.println(Math.random());</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><hr><p><strong>如果被final修饰了 就不能被继承了</strong></p>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2021/09/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/09/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote><p>java的核心思想就是OOP（面向对象编程的缩写）</p></blockquote><h3 id="1-目录"><a href="#1-目录" class="headerlink" title="1.目录"></a>1.目录</h3><p><img src="D:\study\typora\截图\面向对象目录.png"></p><h3 id="2-面向过程和面向对象"><a href="#2-面向过程和面向对象" class="headerlink" title="2.面向过程和面向对象"></a>2.面向过程和面向对象</h3><ul><li><p>面向过程思想（线性思维）</p><ul><li>步骤清晰简单，第一步做什么，第二部做什么…</li><li>面对过程适合处理一些较为简单的问题</li></ul></li><li><p>面向对象思想</p><ul><li>物以类聚，<strong>分类</strong>的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，对某些分类下的细节进行面向过程的思索。</li><li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li></ul></li><li><p><strong>对于描述复杂的事物，为了从宏观上把握，从整体上合理分析，我们需要使用<em>面对对象</em>的思路来分析整个系统。但是具体到微观操作，仍然需要<em>面向过程</em>的思路去处理。</strong></p></li></ul><hr><h3 id="3-什么是面向对象"><a href="#3-什么是面向对象" class="headerlink" title="3.什么是面向对象"></a>3.什么是面向对象</h3><ul><li>面向对象编程（object-Oriented Programming，OOP）</li><li>面向对象编程的本质就是：<strong>以类的方式组织代码，以对象的组织（封装）数据</strong></li><li><strong>抽象</strong></li><li>三大特性<ul><li><strong>封装</strong></li><li><strong>继承</strong></li><li><strong>多态</strong></li></ul></li><li>从认识论角度考虑是先有对象后有类。<strong>对象，是具体的事物。 类是抽象的，是对对象的抽象</strong></li><li>从代码运行角度考虑是先有类后有对象。<strong>类是对象的模板。</strong></li></ul><hr><h3 id="4-回顾方法及加深"><a href="#4-回顾方法及加深" class="headerlink" title="4.回顾方法及加深"></a>4.回顾方法及加深</h3><p><img src="D:\study\typora\截图\回顾.png"></p><ul><li>break：跳出switch，循环等</li><li>return：代表方法的结束，返回一个结果，结果可为空也可以为其他类型</li><li>方法名：注意规范（驼峰原则），见名知意</li><li>参数列表：（参数类型，参数名……）</li><li>异常抛出（后面再说）</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe">静态方法也就是 <span class="hljs-keyword">static</span> 方法是和类一起加载的，很早很早就存在了<br>非静态方法就是在类实例化之后才存在的，也就是在<span class="hljs-keyword">new</span><span class="hljs-type"></span>之后才算数的<br>所以静态方法里面无法调用非静态方法<br>就是存在的东西不能去调用不存在的东西<br>但是<span class="hljs-keyword">static</span>静态方法可以调用静态方法<br>非静态也可以调用非静态的方法<br>非静态也可以调用静态方法，因为当非静态方法可以调用时，静态方法早就存在了<br>所以存在可以调用存在，所以可以调用<span class="hljs-keyword">static</span>方法<br></code></pre></td></tr></table></figure><ul><li>形参和实参：形式参数和实际参数</li><li>add（1,2）1,2是形式参数</li><li>public int add（int i，int j），i 和 j 都是形式参数</li></ul><p><strong>java是值传递</strong></p><ul><li>值传递和引用传递<ul><li>值传递：</li><li>引用传递：</li></ul></li></ul><hr><h3 id="5、类和对象的关系"><a href="#5、类和对象的关系" class="headerlink" title="5、类和对象的关系"></a>5、类和对象的关系</h3><ul><li>类是一种抽象的数据类型，它是对某一类事物的整体描述/定义，但是并不能代表某一个具体的事物<ul><li>动物、植物、手机、电脑…</li><li>person类、pet类、car类 ，这些类都是用来描述具体的事物应该具备的特点和行为</li></ul></li><li>对象是抽象概念的具体实例<ul><li>比如：张三就是人的一个具体实例，张三家里的旺财就是狗的一个具体实例</li><li>能够体现出特点，展现出功能的是具体实例，而不是一个抽象的概念。</li></ul></li></ul><hr><h3 id="6、创建和初始化对象"><a href="#6、创建和初始化对象" class="headerlink" title="6、创建和初始化对象"></a>6、创建和初始化对象</h3><ul><li>使用new关键字创建对象</li><li>使用new关键字创建的时候，除了<strong>分配内存空间</strong>之外，还会给创建好的对象，进行<strong>默认的初始化</strong>以及<strong>对类中构造器的调用</strong>。</li></ul><ul><li><strong>类中的构造器也称为构造方法</strong>，是在进行创建对象的时候必须调用的，并且构造器有以下两个特点：<ul><li>必须和类的名字相同</li><li>必须没有返回类型，也不能写void</li></ul></li><li><strong>构造器必须掌握</strong></li></ul><h3 id="7、构造类详解"><a href="#7、构造类详解" class="headerlink" title="7、构造类详解"></a>7、构造类详解</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//new 实例化了一个对象</span><br>Person person = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>();<br><span class="hljs-comment">//new一个有参对象</span><br>Person person1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;jiaxu&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>构造器</strong></p><ol><li>和类名相同</li><li>没有返回值</li></ol><p><strong>作用：</strong></p><ol><li>new 本质就是在调用构造方法</li><li>初始化对象的值</li></ol><p><strong>注意点：</strong></p><ol><li>定义有参构造之后，如果想继续使用无参构造，显示的定义一个无参的构造函数</li></ol><p><strong>快捷键</strong></p><p>alt + insert ： 直接生成构造函数，get、set方法等</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.demoo2;<br><br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:吴家旭</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>:2021/3/23 - 20:08</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">//一个类即使什么都没有写，它也会有一个方法</span><br>    <span class="hljs-comment">//显示的定义构造器</span><br><br>    String name;<br><br>    <span class="hljs-comment">//实例化初始值</span><br>    <span class="hljs-comment">//1.使用new关键字，本质就是调用构造器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br><br><br>    <span class="hljs-comment">//有参构造：一旦定义了有参构造，无参就必须显示定义</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">//alt+insert</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="7-创建对象的内存分析"><a href="#7-创建对象的内存分析" class="headerlink" title="7.创建对象的内存分析"></a>7.创建对象的内存分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pet dog = <span class="hljs-keyword">new</span> Pet();<br>        dog.name = <span class="hljs-string">&quot;旺财&quot;</span>;<br>        dog.age = <span class="hljs-number">3</span>;<br>        dog.shout();<br>        System.out.println(dog.name);<br>        System.out.println(dog.age);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;叫了一声&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Pet dog = <span class="hljs-keyword">new</span> Pet();<br></code></pre></td></tr></table></figure><p><strong>内存情况</strong></p><p><img src="D:\study\typora\截图\new内存.png"></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dog.name</span> = <span class="hljs-string">&quot;旺财&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attr">dog.age</span> = <span class="hljs-number">3</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>内存状况</strong></p><p><img src="D:\study\typora\截图\赋值.png"></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Pet cat</span> = new Pet();<br></code></pre></td></tr></table></figure><p><img src="D:\study\typora\截图\内存最终.png"></p><p><strong>堆栈情况</strong></p><p><img src="D:\study\typora\截图\内存情况.png"></p>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2021/09/29/%E6%95%B0%E7%BB%84/"/>
    <url>/2021/09/29/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>2021/03/15 星期一</p></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="D:\study\typora\截图\目录.png"></p><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p><img src="D:\study\typora\截图\数组定义.png"></p><ul><li><p>数组是相同类型的数据的有序集合</p></li><li><p>数组描述的是相同类型的若干个数据，按照一定的先后次序排序组合而成</p></li><li><p>其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们</p></li><li><p>数组的下标是从0开始的</p></li></ul><hr><h3 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h3><p><img src="D:\study\typora\截图\数组的创建.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu.array;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:吴家旭</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>:2021/3/17 - 20:13</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayDemo01</span> </span>&#123;<br>    <span class="hljs-comment">//变量类型     变量名字     =  变量的值；</span><br>    <span class="hljs-comment">//数组类型</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] nums;<span class="hljs-comment">//定义   常用  声明了一个数组</span><br>        <span class="hljs-keyword">int</span> nums2[]; <span class="hljs-comment">//这是早些年为了c++程序员转到java而是用的写法，一般不用</span><br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//这里面可以存放10个int类型的数字  创建了一个数组</span><br><br>        <span class="hljs-comment">//给数组元素赋值</span><br>        nums[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        nums[<span class="hljs-number">1</span>]=<span class="hljs-number">7</span>;<br>        nums[<span class="hljs-number">2</span>]=<span class="hljs-number">6</span>;<br>        nums[<span class="hljs-number">3</span>]=<span class="hljs-number">5</span>;<br>        nums[<span class="hljs-number">4</span>]=<span class="hljs-number">4</span>;<br>        nums[<span class="hljs-number">5</span>]=<span class="hljs-number">3</span>;<br>        nums[<span class="hljs-number">6</span>]=<span class="hljs-number">2</span>;<br>        nums[<span class="hljs-number">7</span>]=<span class="hljs-number">1</span>;<br>        nums[<span class="hljs-number">8</span>]=<span class="hljs-number">1</span>;<br>        nums[<span class="hljs-number">9</span>]=<span class="hljs-number">1</span>;<br><br>        System.out.println(nums.length);<br>        System.out.println(nums[<span class="hljs-number">9</span>]);<span class="hljs-comment">//int 数组的默认值是0</span><br><br>        <span class="hljs-comment">//计算所有元素的和</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            sum += nums[i];<br>        &#125;<br>        System.out.println(sum);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p><img src="D:\study\typora\截图\内存.png"></p><p><img src="D:\study\typora\截图\内存状况.png"></p><p><strong>java内存</strong></p><ol><li>堆：<ul><li>存放new的对象和数组</li><li>可以被所有线程共享，不会存放别的对象引用</li></ul></li><li>栈<ul><li>存放基本变量类型（会包括这个类型的具体数值）</li><li>引用对象的变量（会存放这个引用在堆里的具体地址）</li></ul></li><li>方法区<ul><li>可以被所有线程共享</li><li>包括了所有的class和static变量</li></ul></li></ol><hr><p><strong>数组越界提示词</strong></p><p><strong>java.lang.ArrayIndexOutOfBoundsException</strong></p><hr><h3 id="三种初始化"><a href="#三种初始化" class="headerlink" title="三种初始化"></a>三种初始化</h3><img src="D:\study\typora\截图\数组初始化.png" style="zoom:80%;" /><h3 id="数组的四个基本特点"><a href="#数组的四个基本特点" class="headerlink" title="数组的四个基本特点"></a>数组的四个基本特点</h3><ul><li>其长度是确定的，数组一旦被创建，它的大小就是不可以改变的</li><li>其元素必须是相同类型，不允许出现混合类型</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型</li><li>数组变量是引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量</li></ul><p>数组本身就是对象，java中对象也是在堆中，因此数组无论保存原始类型还是其他对象类型，<strong>数组对象本身是在堆中</strong></p><hr><h3 id="数组边界"><a href="#数组边界" class="headerlink" title="数组边界"></a>数组边界</h3><ul><li>下标的合法区间：[0, length-1],如果越界就会报错：</li></ul><p><img src="D:\study\typora\截图\报错.png"></p><hr><p><strong>小结</strong></p><ul><li>数组是相同数据类型（数据类型可以是任何类型）的有序集合</li><li>数组也是对象。数组元素相当于对象的成员变量</li><li>数组的长度是确定的，不可变得，如果越界，则报错</li><li>ArrayIndexOUTofBounds</li></ul>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java方法详解</title>
    <link href="/2021/09/28/java%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/09/28/java%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="java方法详解"><a href="#java方法详解" class="headerlink" title="java方法详解"></a>java方法详解</h2><blockquote><p>2021/03/15 星期一</p></blockquote><p><img src="D:\study\typora\截图\方法目录.png"></p><p><strong>java方法是语句的集合，它们扎起一起执行一个功能</strong></p><ul><li>方法是解决一类问题的步骤的有序集合</li><li>方法包含于类或者对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul><hr><p>设计方法原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的<strong>原子性</strong>，<em><strong>就是一个方法只完成一个功能，这样利于我们后期的拓展</strong></em></p><hr><h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h3><p><img src="D:\study\typora\截图\定义.png"></p><hr><h3 id="方法的构成"><a href="#方法的构成" class="headerlink" title="方法的构成"></a>方法的构成</h3><p><strong>方法包含一个方法头和一个方法体</strong></p><p>构成：</p><p><img src="D:\study\typora\截图\方法构成.png" alt="方法构成"></p><p>修饰符：(还有很多)</p><p><img src="D:\study\typora\截图\修饰符.png" alt="修饰符"></p><blockquote><p>接口里的方法默认情况下的访问权限为public</p></blockquote><blockquote><p><strong>修饰符不仅仅只有访问控制修饰符，其他的在后面再学习</strong></p></blockquote><p><strong>函数的结构   如图</strong></p><p><img src="D:\study\typora\截图\结构图.png"></p><hr><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul><li><p>调用方法：对象名.方法名(实参列表)</p></li><li><p>java支持两种调用方法的方式：根据方法是否返回值来选择</p><ul><li><p>当方法返回一个值得时候，方法调用通常被当做一个值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> larger = max(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure></li><li><p>当方法返回值是void，方法调用一定是一条语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;hello world!!&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p><strong>一、值传递</strong></p><blockquote><p><em><strong>java都是值传递</strong></em></p></blockquote><p>**值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将  <em>不会影响到实际参数</em>  **</p><hr><p><strong>二、引用传递</strong></p><p><strong>引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将  <em>影响到实际参数。</em></strong></p><p><img src="D:\study\typora\截图\值传递与引用传递的区别.png"></p><p><img src="D:\study\typora\截图\比喻.png" alt="比喻"></p><p><img src="D:\study\typora\截图\java值传递.png"></p><hr><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><blockquote><p>定义：重载就是在一个类中，有相同的函数名称，但是形参不同的函数</p></blockquote><p><strong>方法重载的规则</strong></p><ul><li>方法名称必须相同</li><li>参数列表必须不同（个数不同、或者类型不同、或者参数排列不同等）。</li><li>方法的放回类型可以相同也可以不同</li><li>仅仅返回类型不同不足以成为方法的重载</li></ul><p><strong>实现理论：</strong></p><ul><li>方法名称相同时，编译器会根据调用方法的参数个数，参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li></ul><hr><h3 id="命令行传参（了解即可）"><a href="#命令行传参（了解即可）" class="headerlink" title="命令行传参（了解即可）"></a>命令行传参（了解即可）</h3><p><img src="D:\study\typora\截图\命令行传参.png"></p><hr><h3 id="可变参数（了解就好了）"><a href="#可变参数（了解就好了）" class="headerlink" title="可变参数（了解就好了）"></a>可变参数（了解就好了）</h3><p><img src="D:\study\typora\截图\可变参数.png"></p><blockquote><p>注意：</p><ul><li>一个方法中只能指定一个可变参数</li><li>必须是最后一个参数</li></ul></blockquote><hr><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><img src="D:\study\typora\截图\递归.png"></p><blockquote><p>注意：</p><ul><li>递归就是最近调用自己</li></ul><p>递归结构包括两个部分：</p><ul><li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。</li><li>递归体：什么时候需要调用自身方法</li></ul><p>故我们需要：</p><ul><li>确认边界条件：</li></ul><p><strong>小次数可以用递归，多次数就不要用递归了</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scanner</title>
    <link href="/2021/09/27/Scanner/"/>
    <url>/2021/09/27/Scanner/</url>
    
    <content type="html"><![CDATA[<h2 id="浅谈scanner"><a href="#浅谈scanner" class="headerlink" title="浅谈scanner"></a>浅谈scanner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个扫描器对象，用于接收键盘数据</span><br>Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure><p>创建scanner对象，便于用户输入数据，提高交互</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//凡是属于IO流的类如果不关闭就会一直占用资源，要养成好习惯用完就关掉</span><br><br>scanner.close();<br></code></pre></td></tr></table></figure><p>用完就关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//scanner的相关函数</span><br>scanner.next();<span class="hljs-comment">//获取下一个字符</span><br>scanner.nextLine();<span class="hljs-comment">//获取下一行</span><br>scanner.nextInt();<span class="hljs-comment">//获取下一个整数</span><br>scanner.next数据类型();<span class="hljs-comment">//对于每个数据类型，scanner都有相对应的next去获取你输入的数据</span><br><br><span class="hljs-comment">//下面这几个hasNext**函数都是返回boolean类型，用于判断还有没有下一个</span><br>scanner.hasNext();<br>scanner.hasNextLine();<span class="hljs-comment">//判断还有没有下一行</span><br>scanner.hasNext数据类型();<span class="hljs-comment">//判断还有没有下一个这个类型的数据</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包机制和文档注释</title>
    <link href="/2021/09/26/%E5%8C%85%E6%9C%BA%E5%88%B6%E5%92%8C%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/"/>
    <url>/2021/09/26/%E5%8C%85%E6%9C%BA%E5%88%B6%E5%92%8C%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="包机制和文档注释"><a href="#包机制和文档注释" class="headerlink" title="包机制和文档注释"></a>包机制和文档注释</h2><blockquote><p>2021/03/15 星期一</p></blockquote><h3 id="一、包机制"><a href="#一、包机制" class="headerlink" title="一、包机制"></a>一、包机制</h3><p><strong>类似文件夹：可以在不同文件夹中放置相同命名的类型文件</strong></p><p><img src="D:\study\typora\截图\包机制.png"></p><p><strong>一般用域名倒置作为包名</strong></p><p><strong>在java中导包</strong></p><img src="D:\study\typora\截图\导包.png" alt="导包" style="zoom:150%;" /><hr><h3 id="二、javadoc（文档注释）"><a href="#二、javadoc（文档注释）" class="headerlink" title="二、javadoc（文档注释）"></a>二、javadoc（文档注释）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在java中的文档注释</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"><span class="hljs-doctag">@author</span>:wujiaxu</span><br><span class="hljs-comment"><span class="hljs-doctag">@version</span> 1.8</span><br><span class="hljs-comment"><span class="hljs-doctag">@since</span> 指明最低版本1.8</span><br><span class="hljs-comment"><span class="hljs-doctag">@param</span> 参数</span><br><span class="hljs-comment"><span class="hljs-doctag">@return</span> 返回值情况</span><br><span class="hljs-comment"><span class="hljs-doctag">@throws</span> 异常抛出情况</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>在命令行中使用javadoc 文件名.java 即可生成注释文档</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#生成注释文档</span><br>javadoc -encoding UTF-8 -charset UTF-8 doc.java<br><span class="hljs-comment">#格式：javadoc 参数 文件名.java</span><br></code></pre></td></tr></table></figure><hr><p><strong>在idea中生成注释文档</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Tools-----&gt;Generate javaDoc---&gt;出现下面的界面-----&gt;第一个是整个项目  第二个是当前这位类</span><br><span class="hljs-comment">#----&gt;选择output directory（doc输出的地方）</span><br></code></pre></td></tr></table></figure><img src="D:\study\typora\截图\IDEAjavadoc.png" style="zoom:60%;" />]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关idea</title>
    <link href="/2021/09/25/%E6%9C%89%E5%85%B3idea/"/>
    <url>/2021/09/25/%E6%9C%89%E5%85%B3idea/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2021/03/08 星期一</p></blockquote><h1 id="关于idea"><a href="#关于idea" class="headerlink" title="关于idea"></a>关于idea</h1><h2 id="一、idea的快捷键"><a href="#一、idea的快捷键" class="headerlink" title="一、idea的快捷键"></a>一、idea的快捷键</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">alt + enter <span class="hljs-comment">#万能纠错/生成返回值变量</span><br><span class="hljs-built_in">shift</span> + enter <span class="hljs-comment">#换行</span><br>ctrl + <span class="hljs-built_in">shift</span> + enter <span class="hljs-comment">#自动</span><br>alt + down <span class="hljs-comment">#向下换行 其他同理</span><br>ctrl + 选择的函数左键 <span class="hljs-comment">#查看源代码</span><br>ctrl + y <span class="hljs-comment">#删除光标所在行</span><br>ctrl + alt + / <span class="hljs-comment">#提示方法参数类型</span><br>Ctrl + <span class="hljs-built_in">shift</span> + / <span class="hljs-comment">#代码块注释</span><br>ctrl + <span class="hljs-built_in">shift</span> + u <span class="hljs-comment">#变化大小写</span><br>ctrl + <span class="hljs-built_in">shift</span> + space <span class="hljs-comment">#智能代码提示</span><br>ctrl + <span class="hljs-built_in">shift</span> + R <span class="hljs-comment">#根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件</span><br>ctrl + <span class="hljs-built_in">shift</span> + F <span class="hljs-comment">#查找整个项目或者指定目录的文件</span><br>ctrl + D <span class="hljs-comment"># 复制当前行到下一行</span><br></code></pre></td></tr></table></figure><h2 id="二、模板"><a href="#二、模板" class="headerlink" title="二、模板"></a>二、模板</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建主函数</span><br>psvm  / main<br><br><span class="hljs-comment">#输出</span><br>sout<br>soutv<br>soutm<br>soutp<br>xxx.sout<br><br><span class="hljs-comment">#for循环</span><br>fori<br>变形：iter加强<span class="hljs-keyword">for</span>循环<br>变形：itar普通<span class="hljs-keyword">for</span>循环<br><span class="hljs-comment">#集合list的for循环</span><br>list.for<br>list.fori<br>list.forr<span class="hljs-comment">#倒序循环</span><br><br><span class="hljs-comment">#ifn</span><br><span class="hljs-keyword">if</span>(list == null)<br>变形：inn 不等于null<br> xxx.nn<br>变形：xxx.null <br><br><br><span class="hljs-comment">#prsf等</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量和运算符</title>
    <link href="/2021/09/24/%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/09/24/%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="变量和运算符"><a href="#变量和运算符" class="headerlink" title="变量和运算符"></a>变量和运算符</h1><blockquote><p>2021/03/10 星期三</p></blockquote><h2 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h2><p>定义：可以变化的量</p><p>**java变量是程序中最基础的存储单元，其要素包括变量名，变量类型 和  <em>作用域</em> **</p><hr><p><strong>变量名的命名原则</strong></p><p><img src="D:\study\typora\截图\变量命名原则.png" alt="图片"></p><p><strong>变量的类型</strong></p><ol><li>局部变量</li><li>类变量</li><li>全局变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> base;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>：吴家旭</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>：2021/3/9 - 20:29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo07</span> </span>&#123;<br><br>    <span class="hljs-comment">//类变量static</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> salary = <span class="hljs-number">2500</span>;<br><br><br>    <span class="hljs-comment">//属性：变量</span><br><br>    <span class="hljs-comment">//实例变量：从属于对象; 如果不初始化，自动赋值为0或者0.0</span><br>    <span class="hljs-comment">//布尔值：默认为false</span><br>    <span class="hljs-comment">//除了基本类型，其余的默认值都为null</span><br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br><br><br>    <span class="hljs-comment">//main方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//局部变量：必须声明和初始化值</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><br>        <span class="hljs-comment">//变量类型  变量名字 = new base.Demo07</span><br>        Demo07 demo07 = <span class="hljs-keyword">new</span> Demo07();<br>        System.out.println(<span class="hljs-string">&quot;demo07.age = &quot;</span> + demo07.age);<br>        System.out.println(<span class="hljs-string">&quot;demo07.name = &quot;</span> + demo07.name);<br>        System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>        <span class="hljs-comment">//类变量 static</span><br>        System.out.println(<span class="hljs-string">&quot;salary = &quot;</span> + salary);<br>    &#125;<br><br>    <span class="hljs-comment">//其他方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>修饰符是不存在先后顺序的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修饰符不存在先后顺序</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">3.14</span>;<br><span class="hljs-comment">//static final double PI = 3.14;  和上面是相等的</span><br></code></pre></td></tr></table></figure></blockquote><hr><h2 id="二、常量"><a href="#二、常量" class="headerlink" title="二、常量"></a>二、常量</h2><blockquote><p>定义：初始化之后，就不再改变值！不会变动的值</p><p>用关键字<strong>final</strong>修饰</p><p>常量名一般大写</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h2><blockquote><p>运算符类别</p><ol><li>算数运算符</li><li>赋值运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符（了解即可）</li><li>条件运算符</li><li>扩展运算符</li></ol></blockquote><p><strong>运算符</strong></p><p><img src="D:\study\typora\截图\运算符.png" alt="运算符"></p><p><strong>一旦有高等级</strong>（例如 long，double），计算出来的结果也是 <strong>对应的高等级</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java注释和标识符和数据类型</title>
    <link href="/2021/09/23/java%E6%B3%A8%E9%87%8A%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/09/23/java%E6%B3%A8%E9%87%8A%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="java注释、标识符和数据类型"><a href="#java注释、标识符和数据类型" class="headerlink" title="java注释、标识符和数据类型"></a>java注释、标识符和数据类型</h1><h2 id="java注释"><a href="#java注释" class="headerlink" title="java注释"></a>java注释</h2><blockquote><p>2021/03/09  星期二</p></blockquote><p><strong>注释类型</strong></p><ol><li>单行注释</li><li>多行注释</li><li>文档注释（javadoc）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-comment">//这是单行注释</span><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    这是多行注释</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    <span class="hljs-doctag">@author</span>:吴家旭</span><br><span class="hljs-comment">    这是文档注释</span><br><span class="hljs-comment">    里面<span class="hljs-doctag">@author</span>等描述是可以被系统识别的</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="java的数据类型"><a href="#java的数据类型" class="headerlink" title="java的数据类型"></a>java的数据类型</h2><blockquote><p>java 是一种强类型的语言   </p><p>要求变量的使用严格符合规定 </p><p>需要先定义后使用</p></blockquote><h3 id="两大类"><a href="#两大类" class="headerlink" title="两大类"></a>两大类</h3><h4 id="一、基本类型-primitive-type"><a href="#一、基本类型-primitive-type" class="headerlink" title="一、基本类型 primitive type"></a>一、基本类型 primitive type</h4><ol><li>数值类型<ul><li>整数类型</li><li>浮点类型</li><li>字符类型</li></ul></li><li>boolean类型<ul><li>true</li><li>false</li></ul></li></ol><hr><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><p>​        <em><strong>整数类型</strong></em></p><ul><li>byte</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">byte占一个字节范围：-128-127<br></code></pre></td></tr></table></figure><ul><li>short </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">占两个字节 范围：-32768 - 32767<br></code></pre></td></tr></table></figure><ul><li>int</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">int 占四个字节<br></code></pre></td></tr></table></figure><ul><li><p>long</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">占八个字节<br></code></pre></td></tr></table></figure><p><em><strong>浮点类型</strong></em></p></li><li><p>float</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#占四个字节</span><br></code></pre></td></tr></table></figure><ul><li>double</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#占八个字节</span><br></code></pre></td></tr></table></figure><p>​    <em><strong>字符类型</strong></em></p><ul><li>char</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#占八个字节</span><br></code></pre></td></tr></table></figure><hr><h5 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h5><p>​    <em><strong>boolean</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#只有true 和false</span><br><span class="hljs-comment">#而且只占一位</span><br></code></pre></td></tr></table></figure><hr><blockquote><p>拓展知识：</p><p>位（bit）：计算机数据储存的最小单位</p><p>字节（byte）：1B（字节） = 8bit（位）；计算机数据处理的基本单位，习惯用大写                            B</p></blockquote><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> base;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>：吴家旭</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>：2021/3/9 - 9:46</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 整数拓展：</span><br><span class="hljs-comment">        * 进制   二进制0b   十进制    八进制0      十六进制0x</span><br><span class="hljs-comment">        * */</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> i2 = <span class="hljs-number">010</span>;<br>        <span class="hljs-keyword">int</span> i3 = <span class="hljs-number">0x10</span>;<br>        System.out.println(i);<br>        System.out.println(i2);<br>        System.out.println(i3);<br>        System.out.println(<span class="hljs-string">&quot;====================&quot;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 浮点数拓展：</span><br><span class="hljs-comment">        * 银行业务怎么表示？钱</span><br><span class="hljs-comment">        * 用BigDecimal 数学工具类</span><br><span class="hljs-comment">        * float      有限 离散 舍入误差 大约 接近但不等于</span><br><span class="hljs-comment">        * double</span><br><span class="hljs-comment">        * */</span><br><br>        <span class="hljs-comment">//最好完全不要使用浮点数进行比较</span><br>        <span class="hljs-comment">//最好完全不要使用浮点数进行比较</span><br>        <span class="hljs-comment">//最好完全不要使用浮点数进行比较</span><br>        <span class="hljs-comment">//最好完全不要使用浮点数进行比较</span><br>        <span class="hljs-keyword">float</span> f = <span class="hljs-number">0.1f</span>;<br>        <span class="hljs-keyword">double</span> d = <span class="hljs-number">1.0</span> / <span class="hljs-number">10</span>;<br>        System.out.println(f == d);<span class="hljs-comment">//返回的是False</span><br>        System.out.println(f);<br>        System.out.println(d);<br>        <span class="hljs-keyword">float</span> d1 = <span class="hljs-number">12344567789239474f</span>;<br>        <span class="hljs-keyword">float</span> d2 = d1 + <span class="hljs-number">1</span>;<br>        System.out.println(d1 == d2);<span class="hljs-comment">//结果竟然是true</span><br><br>        System.out.println(<span class="hljs-string">&quot;====================&quot;</span>);<br>        <span class="hljs-comment">//字符拓展？</span><br><br>        <span class="hljs-keyword">char</span> c1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">char</span> c2 = <span class="hljs-string">&#x27;中&#x27;</span>;<br>        System.out.println(c1);<br>        System.out.println((<span class="hljs-keyword">int</span>)c1);<span class="hljs-comment">//强制转换</span><br>        System.out.println(c2);<br>        System.out.println((<span class="hljs-keyword">int</span>) c2);<span class="hljs-comment">//强制转换</span><br>        <span class="hljs-comment">//所有的字符本质还是数字</span><br>        <span class="hljs-comment">//编码 Unicode 表：97 =&#x27;a&#x27; 2字节 0-65536   Excel 2的16次幂 = 65536</span><br><br><br>        <span class="hljs-comment">//u00000   uFFFFF</span><br>        <span class="hljs-keyword">char</span> c3 = <span class="hljs-string">&#x27;\u0061&#x27;</span>;<br>        System.out.println(c3);  <span class="hljs-comment">//a</span><br><br>        <span class="hljs-comment">//转义字符</span><br>        <span class="hljs-comment">// \t 制表符</span><br>        <span class="hljs-comment">// \n 换行</span><br>        <span class="hljs-comment">//。。。。</span><br>        System.out.println(<span class="hljs-string">&quot;Hello\tWorld&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;=====================&quot;</span>);<br><br>        String sa =<span class="hljs-keyword">new</span>  String(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        String sb = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        System.out.println(sa == sb);  <span class="hljs-comment">//这个是false</span><br><br>        String sc = <span class="hljs-string">&quot;hello world&quot;</span>;<br>        String sd = <span class="hljs-string">&quot;hello world&quot;</span>;<br>        System.out.println(sc == sd); <span class="hljs-comment">//这个是true</span><br><br>        <span class="hljs-comment">//为什么sa == sb 是错的，sc等于sd是对的</span><br>        <span class="hljs-comment">//这个得从对象  内存分析</span><br><br><br><br><br>        <span class="hljs-comment">//布尔值拓展</span><br>        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (flag ==<span class="hljs-keyword">true</span>)&#123;&#125; <span class="hljs-comment">//新手才会写flag == true  ，因为flag就是true了，所以有些多于</span><br>        <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-comment">//老手</span><br>            <span class="hljs-comment">//代码要精简 less is more</span><br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="二、引用类型-reference-type"><a href="#二、引用类型-reference-type" class="headerlink" title="二、引用类型 reference type"></a>二、引用类型 reference type</h4><blockquote><p>除基本类型之外，都是引用类型</p></blockquote><ol><li><strong>类</strong></li><li><strong>接口</strong></li><li><strong>数组</strong></li></ol><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><blockquote><p>由于java的强类型语言，所以要进行有些运算的时候性需要用到类型转换</p><p>运算中，不同类型的数据要先转化为同一个类型，然后进行运算</p><p>注意：</p><p>1.内存溢出  </p><p>2.进度问题</p><p>3.不要用浮点数进行比较（原因：浮点数有舍入误差，存在接近但不等于的问题，是有限的）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从低----------------------------------高</span><br><span class="hljs-comment">//byte  short char int long float double</span><br><br><span class="hljs-comment">//从高到低 -----&gt;强制类型转换</span><br><span class="hljs-comment">//从低到高 -----&gt;自动类型转换</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> base;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>：吴家旭</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>：2021/3/9 - 19:53</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo04</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">128</span>;<br>        <span class="hljs-comment">//如果这时候b是double型就没事</span><br>        <span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>) i;<span class="hljs-comment">//如果没有进行强制转换则会报错， 需要一个byte类型但是i是一个int类型</span><br>        <span class="hljs-comment">//上面b内存溢出</span><br>        <span class="hljs-comment">//强制转换    （类型）变量名   高到低</span><br>        <span class="hljs-comment">//自动类型转换  低---高</span><br>        System.out.println(i);<br>        System.out.println(b);<br>        <span class="hljs-comment">//这时候b = -128，因为内存溢出 byte最大为127</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 注意点：</span><br><span class="hljs-comment">        * 1.不能对布尔值进行转黄</span><br><span class="hljs-comment">        * 2.不能吧对象类型转换为不相干的类型</span><br><span class="hljs-comment">        * 3.再把高容量转换到低容量的时候，强制装换</span><br><span class="hljs-comment">        * 4.转换的时候可能存在内存溢出，或者精度问题</span><br><span class="hljs-comment">        * */</span><br>        System.out.println(<span class="hljs-string">&quot;==============&quot;</span>);<br>        System.out.println((<span class="hljs-keyword">int</span>)<span class="hljs-number">23.7</span>);  <span class="hljs-comment">//23  精度问题</span><br>        System.out.println((<span class="hljs-keyword">int</span>)-<span class="hljs-number">45.89f</span>); <span class="hljs-comment">// -45</span><br><br>        System.out.println(<span class="hljs-string">&quot;===========&quot;</span>);<br>        <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">int</span> d = c + <span class="hljs-number">1</span>;<br>        System.out.println(d);<br>        System.out.println((<span class="hljs-keyword">char</span>) d);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><img src="D:\study\typora\截图\标识符.png" alt="标识符" style="zoom:150%;" /><p><strong>标识符列表</strong></p><blockquote><p>标识符是大小写敏感的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java的特性和优势</title>
    <link href="/2021/09/22/java%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E4%BC%98%E5%8A%BF/"/>
    <url>/2021/09/22/java%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E4%BC%98%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="java的特性和优势"><a href="#java的特性和优势" class="headerlink" title="java的特性和优势"></a>java的特性和优势</h2><blockquote><p>2020/03/07</p></blockquote><p>特性：</p><ol><li>简单性</li><li>面向对象</li><li>可移植性</li><li>高性能</li><li>分布式</li><li>动态性</li><li>多线程</li><li>安全性</li><li>健壮性</li></ol><h2 id="java的三大版本"><a href="#java的三大版本" class="headerlink" title="java的三大版本"></a>java的三大版本</h2><ul><li><strong>javaSE：标准版（桌面程序，控制台开发）</strong></li><li>javaME(已经没落)</li><li><strong>javaEE：E企业级开发</strong></li></ul><h2 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h2><p><em><strong>JDK：Java Development Kit</strong></em></p><p><em><strong>JRE：java Runtime Environment（运行环境）</strong></em></p><p><em><strong>JVM：java Virtual Machine</strong></em></p><h3 id="jdk、jre、jvm的关系"><a href="#jdk、jre、jvm的关系" class="headerlink" title="jdk、jre、jvm的关系"></a>jdk、jre、jvm的关系</h3><p>*<strong>jdk包含jre，jre包含jvm</strong></p><h3 id="JDK的卸载与安装"><a href="#JDK的卸载与安装" class="headerlink" title="JDK的卸载与安装"></a>JDK的卸载与安装</h3><blockquote><p>想安装先学会卸载</p></blockquote><h4 id="卸载JDK"><a href="#卸载JDK" class="headerlink" title="卸载JDK"></a>卸载JDK</h4><ol><li>找到JDK的安装目录并删除</li><li>找到JAVA_HOME的环境变量并删除</li><li>删除path里面有关于JAVA_HOME的所有变量</li><li>cmd里面输入java -version查看是否已经删除成功</li></ol><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><ol><li>百度搜索jdk8，找到下载地址</li><li>同意协议</li><li>下载电脑对应的版本</li><li>双击安装jdk</li><li><strong>记住安装的路径</strong></li><li>配置环境变量<ol><li>我的电脑–&gt;右键–&gt;属性</li><li>环境变量–&gt;创建JAVA_HOME</li><li>配置path变量</li></ol></li><li>测试JDK是否安装成功<ol><li>打开cmd</li><li>输入java -version</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>doc快捷键</title>
    <link href="/2021/09/21/doc%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/09/21/doc%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="doc常用快捷键"><a href="#doc常用快捷键" class="headerlink" title="doc常用快捷键"></a>doc常用快捷键</h1><blockquote><p>2020年3月7号</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#盘符切换 大写字母+:</span><br><span class="hljs-comment">#查看当前目录下的文件：dir</span><br><span class="hljs-comment">#切换目录 cd</span><br>    <span class="hljs-built_in">cd</span> /d f:  跨盘符需要加/d 不跨盘不需要<br>    <span class="hljs-built_in">cd</span> .. 返回上一级<br><br><span class="hljs-comment">#清理屏幕：cls</span><br><br><span class="hljs-comment">#退出终端：exit</span><br><br><span class="hljs-comment">#查看电脑ip：ipconfig</span><br><br><span class="hljs-comment">#打开应用</span><br>    calc 计算机<br>    mspaint 画图<br>    notepad 记事本<br>    <br><span class="hljs-comment">#ping 命令</span><br>ping + 网址<br>如：ping www.baidu.com<br><br><span class="hljs-comment">#文件操作</span><br>md 目录名 <br>rm 目录名<br><span class="hljs-built_in">cd</span>&gt; 文件名<br>del 文件名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javaSE基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1006笨阶乘</title>
    <link href="/2021/09/20/1006%E7%AC%A8%E9%98%B6%E4%B9%98/"/>
    <url>/2021/09/20/1006%E7%AC%A8%E9%98%B6%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h5 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h5><blockquote><p>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。</p><p>相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p><p>例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p><p>另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。</p><p>实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：4<br>输出：7<br>解释：7 =<span class="hljs-number"> 4 </span>*<span class="hljs-number"> 3 </span>/<span class="hljs-number"> 2 </span>+ 1<br></code></pre></td></tr></table></figure><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta">每四个一个循环，顺序是* / + -，所以用 <span class="hljs-keyword">index</span> 对 四 进行取余<br>即 <span class="hljs-keyword">index</span>%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>  *<br>即 <span class="hljs-keyword">index</span>%<span class="hljs-number">4</span> == <span class="hljs-number">1</span>  /<br>即 <span class="hljs-keyword">index</span>%<span class="hljs-number">4</span> == <span class="hljs-number">2</span>  +<br>即 <span class="hljs-keyword">index</span>%<span class="hljs-number">4</span> == <span class="hljs-number">3</span>  -<br><br>我们可以选择用栈来存储乘法除法之后的结果，在用 加  减 来计算数据<br></code></pre></td></tr></table></figure><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_1006</span>笨阶乘 </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">int</span> <span class="hljs-title">clumsy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        stack.push(N);<br>        N--;<br>        <span class="hljs-comment">//用于计算下一个计算法是什么</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (N &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//将计算完的内容存入栈中</span><br>            <span class="hljs-keyword">if</span> (index % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &#123;<br>                stack.push(stack.pop() * N);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index % <span class="hljs-number">4</span> == <span class="hljs-number">1</span>) &#123;<br>                stack.push(stack.pop() / N);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index % <span class="hljs-number">4</span> == <span class="hljs-number">2</span>) &#123;<br>                stack.push(N);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index % <span class="hljs-number">4</span> == <span class="hljs-number">3</span>) &#123;<br>                stack.push(-N);<br>            &#125;<br>            N--;<br>            index++;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            sum += stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        _1006笨阶乘 example = <span class="hljs-keyword">new</span> _1006笨阶乘();<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;<br>        System.out.println(example.clumsy(<span class="hljs-number">10</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode</title>
    <link href="/2021/09/19/LeetCode/"/>
    <url>/2021/09/19/LeetCode/</url>
    
    <content type="html"><![CDATA[<h2 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224.基本计算器"></a>224.基本计算器</h2><blockquote><p>2021/03/10 星期三</p></blockquote><blockquote><p>实现一个基本的计算器来计算一个简单的字符串表达式 s 的值。</p><p>示例 1：</p><p>输入：s = “1 + 1”<br>输出：2<br>示例 2：</p><p>输入：s = “ 2-1 + 2 “<br>输出：3<br>示例 3：</p><p>输入：s = “(1+(4+5+2)-3)+(6+8)”<br>输出：23</p><p>提示：</p><p>1 &lt;= s.length &lt;= 3 * 105<br>s 由数字、’+’、’-‘、’(‘、’)’、和 ‘ ‘ 组成<br>s 表示一个有效的表达式</p></blockquote><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu;<br><br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>：吴家旭</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>：2021/3/10 - 20:27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_224</span>基础计算器 </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(String s)</span></span>&#123;<br>        <span class="hljs-comment">//创建一个栈用来存储符号</span><br>        Deque&lt;Integer&gt; ops = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        ops.push(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>                sign =ops.peek();<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                sign = -ops.peek();<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                ops.push(sign);<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                ops.pop();<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//临时存放每一个数字</span><br>                <span class="hljs-keyword">long</span> num = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (i&lt;n&amp;&amp;Character.isDigit(s.charAt(i)))&#123;<br>                    num = num * <span class="hljs-number">10</span> + s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    i++;<br>                &#125;<br>                <span class="hljs-comment">//实时更新结果</span><br>                result += sign * num;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><span class="hljs-comment">//测试数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-string">&quot;(1+(4+5+2)-3)+(6+8)&quot;</span>;<br>        System.out.println(calculate(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>这道题首先考虑到没有乘除，只有加减运算和括号</p><p>用了栈，sign作为信号，加减，以及括号进栈，用result实时更新计算结果</p><p>这一题的思路：</p><p>用n = s.length;统计string的长度，遍历整个string，</p><p>用s.charAt(i)判断进来的字符是什么</p><p>用else-if语句判断进来的字符属于什么</p><p>如果是空格，则继续下一个字符</p><p>如果是’+’号，则更新sign为正1；</p><p>如果是’-‘号，则更新sign为—ops.peek()，ops.peek()可以使得括号前为’—‘号，则sign的正负相反，若为 ‘+’ 号，则sign值正常；</p><p>如果是’(‘号，则push(sign)更新ops栈里的第一个数字，好用peek()函数检验括号前的符号</p><p>如果是’)’号，则pop()删除ops栈里面的第一个数字，使得括号运算结束</p><hr><blockquote><p><strong>知识点</strong></p><ol><li>Deque容器</li></ol><p> deque容器为一个给定<em><em>**类型*<em><strong>的元素进行</strong>线性处理</em>*，像向量一样，它</em>*</em>*能够快速地随机访问任一个元素*<em><strong>，并且能够高效地</strong></em>*插入和删除*<em><strong>容器的尾部元素。但它又与vector不同，</strong></em>*deque支持高效插入和删除容器的头部元素*<em><strong>，因此也叫做</strong></em>*双端队列****。</p><p><strong>Deque是一个接口，LinkedList 是其实现类</strong></p><ol start="2"><li>LinkedList</li></ol><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p><p>链表可分为单向链表和双向链表。</p><p>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/06/408px-Singly-linked-list.svg_.png" alt="img"></p><p>一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/06/610px-Doubly-linked-list.svg_.png" alt="img"></p><p>Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。</p><p>与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。</p><p><strong>以下情况使用 ArrayList :</strong></p><ul><li>频繁访问列表中的某一个元素。</li><li>只需要在列表末尾进行添加和删除元素操作。</li></ul><p><strong>以下情况使用 LinkedList :</strong></p><ul><li>你需要通过循环迭代来访问列表中的某些元素。</li><li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li></ul><ol start="3"><li>String.charAt(int i)</li></ol><p><strong>字符串的第i个字符是什么（从0开始）</strong></p><ol start="4"><li>Character.isDigit(char ch)</li></ol><p><strong>判断字符ch是否为数字，如果是数字，则返回true，反之，false</strong></p></blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265122668445536"><strong>查看Deque的用法和理解</strong></a></p><p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p><p>我们发现<code>LinkedList</code>真是一个全能选手，它即是<code>List</code>，又是<code>Queue</code>，还是<code>Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 不推荐的写法:</span><br>LinkedList&lt;<span class="hljs-keyword">String</span>&gt; d1 = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedList</span>&lt;&gt;();<br>d1.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br><span class="hljs-comment">// 推荐的写法：</span><br>Deque&lt;<span class="hljs-keyword">String</span>&gt; d2 = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedList</span>&lt;&gt;();<br>d2.offerLast(<span class="hljs-string">&quot;z&quot;</span>);<br></code></pre></td></tr></table></figure><p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p><p><code>Deque</code>实现了一个双端队列（Double Ended Queue），它可以：</p><ul><li>将元素添加到队尾或队首：<code>addLast()</code>/<code>offerLast()</code>/<code>addFirst()</code>/<code>offerFirst()</code>；</li><li>从队首／队尾获取元素并删除：<code>removeFirst()</code>/<code>pollFirst()</code>/<code>removeLast()</code>/<code>pollLast()</code>；</li><li>从队首／队尾获取元素但不删除：<code>getFirst()</code>/<code>peekFirst()</code>/<code>getLast()</code>/<code>peekLast()</code>；</li><li>总是调用<code>xxxFirst()</code>/<code>xxxLast()</code>以便与<code>Queue</code>的方法区分开；</li><li>避免把<code>null</code>添加到队列。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计哈希集合</title>
    <link href="/2021/09/18/%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88-1/"/>
    <url>/2021/09/18/%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88-1/</url>
    
    <content type="html"><![CDATA[<h2 id="705-设计哈希集合"><a href="#705-设计哈希集合" class="headerlink" title="705.设计哈希集合"></a>705.设计哈希集合</h2><blockquote><p>2021/02/14 星期日</p></blockquote><blockquote><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><p>实现 MyHashSet 类：</p><p>void add(key) 向哈希集合中插入值 key 。<br>bool contains(key) 返回哈希集合中是否存在这个值 key 。<br>void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</p><p>示例：</p><p>输入：<br>[“MyHashSet”, “add”, “add”, “contains”, “contains”, “add”, “contains”, “remove”, “contains”]<br>[[], [1], [2], [1], [3], [2], [2], [2], [2]]<br>输出：<br>[null, null, null, true, false, null, true, null, false]</p><p>解释：<br>MyHashSet myHashSet = new MyHashSet();<br>myHashSet.add(1);      // set = [1]<br>myHashSet.add(2);      // set = [1, 2]<br>myHashSet.contains(1); // 返回 True<br>myHashSet.contains(3); // 返回 False ，（未找到）<br>myHashSet.add(2);      // set = [1, 2]<br>myHashSet.contains(2); // 返回 True<br>myHashSet.remove(2);   // set = [1]<br>myHashSet.contains(2); // 返回 False ，（已移除）</p><p>提示：</p><p>0 &lt;= key &lt;= 106<br>最多调用 104 次 add、remove 和 contains 。</p></blockquote><p><strong>简单数组解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[] nodes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">1000009</span>];<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        nodes[key] = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        nodes[key] = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nodes[key];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>链表解法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jiaxu;<br><br><span class="hljs-keyword">import</span> java.security.Key;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>：吴家旭</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>：2021/3/14 - 20:43</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_705</span>哈希集合 </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Your MyHashSet object will be instantiated and called as such:</span><br><span class="hljs-comment">     * MyHashSet obj = new MyHashSet();</span><br><span class="hljs-comment">     * obj.add(key);</span><br><span class="hljs-comment">     * obj.remove(key);</span><br><span class="hljs-comment">     * boolean param_3 = obj.contains(key);</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] data;<span class="hljs-comment">//链表数组？</span><br>    <span class="hljs-keyword">public</span> _705哈希集合()&#123;<span class="hljs-comment">//初始化</span><br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; i++) &#123;<br>            data[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">// 添加操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-comment">//通过hash计算出要放在哪个链表数组里的下标</span><br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        <span class="hljs-comment">//创建一个链表的迭代器，来接收链表的内容</span><br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-comment">//判断链表的的内容是否还有下一个</span><br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-comment">//将链表的内容赋予element</span><br>            Integer element = iterator.next();<br>            <span class="hljs-comment">//如果内容相等，则返回空，不做操作</span><br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果内容不相同，则添加入链表</span><br>        data[h].offerLast(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                data[h].remove(element);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        _705哈希集合 hashtable = <span class="hljs-keyword">new</span> _705哈希集合();<br>        hashtable.add(<span class="hljs-number">1</span>);<br>        hashtable.add(<span class="hljs-number">2</span>);<br>        hashtable.add(<span class="hljs-number">3</span>);<br>        hashtable.add(<span class="hljs-number">4</span>);<br><br>        System.out.println(hashtable.contains(<span class="hljs-number">1</span>));<br>        hashtable.remove(<span class="hljs-number">1</span>);<br>        System.out.println(hashtable.contains(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在服务器安装mysql教程</title>
    <link href="/2021/09/03/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85mysql%E6%95%99%E7%A8%8B/"/>
    <url>/2021/09/03/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85mysql%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="在Cantos7环境下，服务器安装MySQL"><a href="#在Cantos7环境下，服务器安装MySQL" class="headerlink" title="在Cantos7环境下，服务器安装MySQL"></a>在Cantos7环境下，服务器安装MySQL</h2><h4 id="1-下载MySQL官方的-Yum-Repository"><a href="#1-下载MySQL官方的-Yum-Repository" class="headerlink" title="1.下载MySQL官方的 Yum Repository"></a>1.下载MySQL官方的 Yum Repository</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm<br></code></pre></td></tr></table></figure><blockquote><p>前提是要有wget ：wget是从网络上拉取资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#下载wget</span><br>yum install wget<br></code></pre></td></tr></table></figure></blockquote><h4 id="2-安装MySQL官方的-Yum-Repository"><a href="#2-安装MySQL官方的-Yum-Repository" class="headerlink" title="2.安装MySQL官方的 Yum Repository"></a>2.安装MySQL官方的 Yum Repository</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ivh mysql-community-release-el7-5.noarch.rpm<br></code></pre></td></tr></table></figure><blockquote><p>安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在路径：/etc/yum.repos.d文件夹下有：以下两个文件</span><br>mysql-community.repo<br>mysql-community-source.repo<br></code></pre></td></tr></table></figure></blockquote><h4 id="3-安装MySQL"><a href="#3-安装MySQL" class="headerlink" title="3.安装MySQL"></a>3.安装MySQL</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install mysql-server<br></code></pre></td></tr></table></figure><blockquote><p>四五步没试过，可以从第三步，然后就第六步</p></blockquote><h4 id="4-启动MySQL"><a href="#4-启动MySQL" class="headerlink" title="4.启动MySQL"></a>4.启动MySQL</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mysqld.service<br></code></pre></td></tr></table></figure><h4 id="5-查看MySQL运行状态"><a href="#5-查看MySQL运行状态" class="headerlink" title="5.查看MySQL运行状态"></a>5.查看MySQL运行状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status mysqld.service<br></code></pre></td></tr></table></figure><h4 id="6-查看MySQL运行状态"><a href="#6-查看MySQL运行状态" class="headerlink" title="6.查看MySQL运行状态"></a>6.查看MySQL运行状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo service mysqld status<br></code></pre></td></tr></table></figure><h4 id="7-设置无密码登录（由于第一次安装，所以会不知道密码，设置跳过密码登录）"><a href="#7-设置无密码登录（由于第一次安装，所以会不知道密码，设置跳过密码登录）" class="headerlink" title="7.设置无密码登录（由于第一次安装，所以会不知道密码，设置跳过密码登录）"></a>7.设置无密码登录（由于第一次安装，所以会不知道密码，设置跳过密码登录）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic">--在根目录的\etc\my.cnf文件中添加一行“skip-grant-tables”，就是绕过密码验证<br></code></pre></td></tr></table></figure><h4 id="8-重启MySQL服务"><a href="#8-重启MySQL服务" class="headerlink" title="8.重启MySQL服务"></a>8.重启MySQL服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart mysqld.service<br></code></pre></td></tr></table></figure><h4 id="9-进入MySQL服务"><a href="#9-进入MySQL服务" class="headerlink" title="9.进入MySQL服务"></a>9.进入MySQL服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#直接敲入</span><br>mysql<br><span class="hljs-comment">#这样就可以进入MySQL服务了</span><br></code></pre></td></tr></table></figure><h4 id="10-设置root密码"><a href="#10-设置root密码" class="headerlink" title="10.设置root密码"></a>10.设置root密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">--进入mysql这个表<br>use mysql<br>--更新mysql中root的密码<br>update mysql.user set authentication_string&#x3D;password(&#39;123456&#39;) where user &#x3D; &#39;root&#39;;<br>--刷新数据库<br>flush privileges;<br>--离开数据库<br>quit<br></code></pre></td></tr></table></figure><h4 id="11-将无密码登录删除"><a href="#11-将无密码登录删除" class="headerlink" title="11.将无密码登录删除"></a>11.将无密码登录删除</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic">--在根目录的\etc\my.cnf文件中删除一行“skip-grant-tables”，就是不绕过密码验证<br></code></pre></td></tr></table></figure><h4 id="12-用密码登录"><a href="#12-用密码登录" class="headerlink" title="12.用密码登录"></a>12.用密码登录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -uroot -p<br></code></pre></td></tr></table></figure><h4 id="13-创建角色赋予权限"><a href="#13-创建角色赋予权限" class="headerlink" title="13.创建角色赋予权限"></a>13.创建角色赋予权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建所有ip都可以进去的角色wjxzzf 密码是123456<br>create user &#39;wjxzzf&#39;@&#39;%&#39; indentified by &#39;123456&#39;;<br>#赋予全部权限<br>grant all on *.* TO &#39;wjxzzf&#39;@&#39;%&#39;;<br>#更新数据库<br>flush privileges;<br>#退出数据库<br>quit<br></code></pre></td></tr></table></figure><h4 id="14-给防火墙开放端口"><a href="#14-给防火墙开放端口" class="headerlink" title="14.给防火墙开放端口"></a>14.给防火墙开放端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#开放端口</span><br>firewall-cmd --add-port=3306/tcp -permanent<br><span class="hljs-comment">#刷新端口</span><br>firewall-cmd reload<br><span class="hljs-comment">#查看开放的端口</span><br>firewall-cmd --list-ports<br></code></pre></td></tr></table></figure><h4 id="到此就完成了"><a href="#到此就完成了" class="headerlink" title="到此就完成了"></a>到此就完成了</h4>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/03/18/hello-world/"/>
    <url>/2021/03/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
